{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenGothic Scripting Documentation","text":"<p>This documentation covers the OpenGothic Lua scripting API end to end:</p> <ul> <li>gameplay scripting</li> <li>reusable helper modules</li> <li>event-driven systems</li> <li>Daedalus interoperability for legacy and hybrid mods</li> </ul> <p>The goal is practical modding without C++ rebuild workflows, while still keeping low-level control available where needed.</p>"},{"location":"#what-you-can-build","title":"What You Can Build","text":"<p>With the current scripting API, you can implement:</p> <ul> <li>quest and journal logic</li> <li>dialog gating and option rules</li> <li>custom combat/damage behaviors</li> <li>AI reaction systems</li> <li>inventory/world interaction utilities</li> <li>mixed Lua + Daedalus workflows for gradual migration</li> </ul> <p>For concrete patterns, use the tutorials under Getting Started -&gt; Tutorials.</p>"},{"location":"#api-model","title":"API Model","text":"<p>The API is intentionally layered:</p> <ol> <li>Primitives    Engine-exposed object methods and global functions for direct control.</li> <li>Daedalus bridge <code>opengothic.daedalus.*</code> and <code>opengothic.vm.*</code> for calling existing Daedalus symbols/functions and advanced VM interop.</li> <li>Convenience wrappers    Higher-level APIs in <code>bootstrap.lua</code> that reduce repetitive glue code.</li> </ol> <p>See Core Concept: Architecture for the complete model and tradeoffs.</p>"},{"location":"#how-to-navigate-this-documentation","title":"How to Navigate This Documentation","text":""},{"location":"#if-you-are-new-to-opengothic-lua","title":"If You Are New to OpenGothic Lua","text":"<p>Use this sequence:</p> <ol> <li>Getting Started</li> <li>Your First Mod</li> <li>Continue with tutorials such as:    - Quickloot    - Creating a Simple Quest    - Dialog Time Windows</li> </ol> <p>Then move to Core Concepts before building larger systems.</p>"},{"location":"#if-you-are-an-experienced-daedalus-modder","title":"If You Are an Experienced Daedalus Modder","text":"<p>Start directly with bridge documentation:</p> <ol> <li>Daedalus Bridge Overview</li> <li>Daedalus Bridge Contracts</li> <li>Daedalus Bridge Internals</li> <li>Daedalus Migration Map</li> <li>Daedalus Bridge Recipes</li> </ol> <p>This path is designed for modders familiar with Daedalus/Ikarus/LeGo style workflows who need precise bridge behavior and safe migration patterns.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Getting Started   Setup assumptions, script load model, output channels, and hands-on tutorials.</li> <li>Core Concepts   Architecture, event semantics, lifecycle behavior, and design constraints.</li> <li>API Reference   Detailed method-by-method reference for objects, constants, and helper namespaces.</li> <li>Daedalus Bridge   Strict contracts, internals, migration guidance, and troubleshooting.</li> </ul>"},{"location":"#practical-rules-of-thumb","title":"Practical Rules of Thumb","text":"<ol> <li>Prefer convenience APIs when they already match your target behavior.</li> <li>Use direct bridge calls when no wrapper exists or exact legacy semantics are required.</li> <li>Call bridge functions only when a world/session is active (except <code>daedalus.get</code>, which returns <code>nil</code> safely when no world is loaded).</li> <li>Use <code>opengothic.storage</code> for save-bound persistent state; do not rely on Daedalus globals for persistence across sessions.</li> <li>Use <code>print(...)</code> (or <code>opengothic.ui.debug(...)</code>) for developer/test output and UI notify methods for player-facing messages.</li> </ol>"},{"location":"#start-here","title":"Start Here","text":"<ul> <li>New project: Getting Started</li> <li>Existing Daedalus-heavy mod: Daedalus Bridge Overview</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the OpenGothic Lua API Reference. This section provides a detailed breakdown of all the objects, functions, and constants available to you as a modder.</p>"},{"location":"api-reference/#the-opengothic-table","title":"The <code>opengothic</code> Table","text":"<p>All API functionality is exposed through the single global table <code>opengothic</code>. This includes sub-tables for events, constants, and the Daedalus bridge, as well as functions for accessing global game objects like the <code>World</code> and the <code>Player</code>.</p>"},{"location":"api-reference/#api-layers","title":"API Layers","text":"<p>The API is organized into three layers:</p> <ol> <li>Primitives (direct C++ methods).</li> <li>Daedalus bridge (<code>opengothic.daedalus.*</code>, <code>opengothic.vm.*</code>).</li> <li>Convenience methods (Lua wrappers in <code>bootstrap.lua</code>).</li> </ol> <p>Most modders use convenience methods first, then bridge/primitives for specialized behavior. See Architecture for details.</p>"},{"location":"api-reference/#game-objects","title":"Game Objects","text":"<p>The most common way you will interact with the game is through \"game objects.\" When you get a handle to an NPC, an item, or the world itself, you are given a Lua <code>userdata</code> object with a set of methods you can call.</p> <p>For example, when you get the player object, you can call methods on it like <code>player:displayName()</code> or <code>player:inventory()</code>.</p> <pre><code>local player = opengothic.player()\n\n-- Call the displayName() method on the Npc object\nlocal name = player:displayName()\n\n-- Call the inventory() method to get another object\nlocal inv = player:inventory()\n</code></pre> <p>These objects are the building blocks of your mods. The following pages document the methods available for each object type.</p>"},{"location":"api-reference/#api-ownership-map","title":"API Ownership Map","text":"<p>Each API symbol has exactly one canonical documentation page.</p> <ul> <li><code>world:*</code>, <code>npc:*</code>, <code>item:*</code>, <code>inventory:*</code>, <code>interactive:*</code> live only on object pages.</li> <li><code>opengothic.&lt;namespace&gt;.*</code> tables live only on namespace pages under <code>api-reference/helpers/</code>.</li> <li>Object pages may include a short \"See also\" link to a namespace page, but must not duplicate namespace method docs.</li> </ul>"},{"location":"api-reference/#structure","title":"Structure","text":""},{"location":"api-reference/#core","title":"Core","text":"<ul> <li>Globals: <code>opengothic.*</code> global entry points.</li> <li>Events: Hook names and callback signatures.</li> <li>Storage: Persistent save-backed key/value data.</li> <li>Constants: Built-in enums and constants.</li> </ul>"},{"location":"api-reference/#objects","title":"Objects","text":"<ul> <li>World: <code>world:*</code>.</li> <li>Npc: <code>npc:*</code>.</li> <li>Item: <code>item:*</code>.</li> <li>Inventory: <code>inventory:*</code>.</li> <li>Interactive: <code>interactive:*</code>.</li> </ul>"},{"location":"api-reference/#namespaces","title":"Namespaces","text":"<ul> <li>Quest: <code>opengothic.quest.*</code>.</li> <li>Dialog: <code>opengothic.dialog.*</code>.</li> <li>AI: <code>opengothic.ai.*</code>.</li> <li>Timer: <code>opengothic.timer.*</code>.</li> <li>UI: <code>opengothic.ui.*</code>.</li> <li>Inventory: <code>opengothic.inventory.*</code>.</li> <li>World: <code>opengothic.worldutil.*</code>.</li> <li>Damage Calculator: <code>opengothic.DamageCalculator.*</code>.</li> <li>Sound: <code>opengothic.sound.*</code>.</li> <li>Effect: <code>opengothic.effect.*</code>.</li> </ul>"},{"location":"api-reference/constants/","title":"Constants","text":"<p>The <code>opengothic.CONSTANTS</code> table provides named variables for common \"magic numbers\" used throughout the game's systems. You should always use these constants instead of raw numbers to make your code readable and resilient to future game changes.</p>"},{"location":"api-reference/constants/#accessing-constants","title":"Accessing Constants","text":"<p>You access constants via the global table: <code>opengothic.CONSTANTS.&lt;GroupName&gt;.&lt;ConstantName&gt;</code></p> <p>Example: <pre><code>-- GOOD: Using a constant\nlocal str = player:attribute(opengothic.CONSTANTS.Attribute.ATR_STRENGTH)\n\n-- BAD: Using a raw number\nlocal str = player:attribute(0) -- What is 0? It's hard to tell.\n</code></pre></p>"},{"location":"api-reference/constants/#constant-groups","title":"Constant Groups","text":"<p>Below are the available groups of constants.</p>"},{"location":"api-reference/constants/#attribute","title":"<code>Attribute</code>","text":"<p>Used for getting and setting primary NPC attributes with <code>npc:attribute()</code> and <code>npc:changeAttribute()</code>. - <code>ATR_HITPOINTS</code> - <code>ATR_HITPOINTSMAX</code> - <code>ATR_MANA</code> - <code>ATR_MANAMAX</code> - <code>ATR_STRENGTH</code> - <code>ATR_DEXTERITY</code> - <code>ATR_REGENERATEHP</code> - <code>ATR_REGENERATEMANA</code> - <code>ATR_MAX</code></p>"},{"location":"api-reference/constants/#protection","title":"<code>Protection</code>","text":"<p>Used for getting protection values with <code>npc:protection()</code> and <code>item:protection()</code>. - <code>PROT_BARRIER</code> - <code>PROT_BLUNT</code> - <code>PROT_EDGE</code> - <code>PROT_FIRE</code> - <code>PROT_FLY</code> - <code>PROT_MAGIC</code> - <code>PROT_POINT</code> - <code>PROT_FALL</code> - <code>PROT_MAX</code></p>"},{"location":"api-reference/constants/#talent","title":"<code>Talent</code>","text":"<p>Used for getting and setting talent skills and values with <code>npc:talentSkill()</code>, <code>npc:setTalentSkill()</code>, <code>npc:talentValue()</code>, and <code>npc:hitChance()</code>. - <code>TALENT_UNKNOWN</code> - <code>TALENT_1H</code> - <code>TALENT_2H</code> - <code>TALENT_BOW</code> - <code>TALENT_CROSSBOW</code> - <code>TALENT_PICKLOCK</code> - <code>TALENT_MAGE</code> - <code>TALENT_SNEAK</code> - <code>TALENT_REGENERATE</code> - <code>TALENT_FIREMASTER</code> - <code>TALENT_ACROBAT</code> - <code>TALENT_PICKPOCKET</code> - <code>TALENT_SMITH</code> - <code>TALENT_RUNES</code> - <code>TALENT_ALCHEMY</code> - <code>TALENT_TAKEANIMALTROPHY</code> - <code>TALENT_FOREIGNLANGUAGE</code> - <code>TALENT_WISPDETECTOR</code> - <code>TALENT_C</code> - <code>TALENT_D</code> - <code>TALENT_E</code> - <code>TALENT_MAX_G1</code> - <code>TALENT_MAX_G2</code></p>"},{"location":"api-reference/constants/#bodystate","title":"<code>BodyState</code>","text":"<p>Used for checking an NPC's current physical state with <code>npc:hasState()</code>. - <code>BS_NONE</code> - <code>BS_WALK</code> - <code>BS_SNEAK</code> - <code>BS_RUN</code> - <code>BS_SPRINT</code> - <code>BS_SWIM</code> - <code>BS_CRAWL</code> - <code>BS_DIVE</code> - <code>BS_JUMP</code> - <code>BS_CLIMB</code> - <code>BS_FALL</code> - <code>BS_SIT</code> - <code>BS_LIE</code> - <code>BS_INVENTORY</code> - <code>BS_ITEMINTERACT</code> - <code>BS_MOBINTERACT</code> - <code>BS_MOBINTERACT_INTERRUPT</code> - <code>BS_TAKEITEM</code> - <code>BS_DROPITEM</code> - <code>BS_THROWITEM</code> - <code>BS_PICKPOCKET</code> - <code>BS_STUMBLE</code> - <code>BS_UNCONSCIOUS</code> - <code>BS_DEAD</code> - <code>BS_AIMNEAR</code> - <code>BS_AIMFAR</code> - <code>BS_HIT</code> - <code>BS_PARADE</code> - <code>BS_CASTING</code> - <code>BS_PETRIFIED</code> - <code>BS_CONTROLLING</code> - <code>BS_MAX</code> - <code>BS_STAND</code> - <code>BS_MOD_HIDDEN</code> - <code>BS_MOD_DRUNK</code> - <code>BS_MOD_NUTS</code> - <code>BS_MOD_BURNING</code> - <code>BS_MOD_CONTROLLED</code> - <code>BS_MOD_TRANSFORMED</code> - <code>BS_FLAG_INTERRUPTABLE</code> - <code>BS_FLAG_FREEHANDS</code></p>"},{"location":"api-reference/constants/#walkbit","title":"<code>WalkBit</code>","text":"<p>Used for setting an NPC's movement mode with <code>npc:setWalkMode()</code>. - <code>WM_Run</code> - <code>WM_Walk</code> - <code>WM_Sneak</code> - <code>WM_Water</code> - <code>WM_Swim</code> - <code>WM_Dive</code></p>"},{"location":"api-reference/constants/#attitude","title":"<code>Attitude</code>","text":"<p>Used for getting and setting an NPC's attitude towards the player with <code>npc:attitude()</code> and <code>npc:setAttitude()</code>. - <code>ATT_HOSTILE</code> - <code>ATT_ANGRY</code> - <code>ATT_NEUTRAL</code> - <code>ATT_FRIENDLY</code> - <code>ATT_NULL</code></p>"},{"location":"api-reference/constants/#perctype","title":"<code>PercType</code>","text":"<p>Used with the <code>onNpcPerception</code> event to identify the type of perception that fired. - <code>PERC_None</code> - <code>PERC_ASSESSPLAYER</code> - <code>PERC_ASSESSENEMY</code> - <code>PERC_ASSESSFIGHTER</code> - <code>PERC_ASSESSBODY</code> - <code>PERC_ASSESSITEM</code> - <code>PERC_ASSESSMURDER</code> - <code>PERC_ASSESSDEFEAT</code> - <code>PERC_ASSESSDAMAGE</code> - <code>PERC_ASSESSOTHERSDAMAGE</code> - <code>PERC_ASSESSTHREAT</code> - <code>PERC_ASSESSREMOVEWEAPON</code> - <code>PERC_OBSERVEINTRUDER</code> - <code>PERC_ASSESSFIGHTSOUND</code> - <code>PERC_ASSESSQUIETSOUND</code> - <code>PERC_ASSESSWARN</code> - <code>PERC_CATCHTHIEF</code> - <code>PERC_ASSESSTHEFT</code> - <code>PERC_ASSESSCALL</code> - <code>PERC_ASSESSTALK</code> - <code>PERC_ASSESSGIVENITEM</code> - <code>PERC_ASSESSFAKEGUILD</code> - <code>PERC_MOVEMOB</code> - <code>PERC_MOVENPC</code> - <code>PERC_DRAWWEAPON</code> - <code>PERC_OBSERVESUSPECT</code> - <code>PERC_NPCCOMMAND</code> - <code>PERC_ASSESSMAGIC</code> - <code>PERC_ASSESSSTOPMAGIC</code> - <code>PERC_ASSESSCASTER</code> - <code>PERC_ASSESSSURPRISE</code> - <code>PERC_ASSESSENTERROOM</code> - <code>PERC_ASSESSUSEMOB</code> - <code>PERC_Count</code></p>"},{"location":"api-reference/events/","title":"Events Reference","text":"<p>The event system allows Lua scripts to respond to game events. Register handlers using <code>opengothic.events.register()</code>.</p>"},{"location":"api-reference/events/#registering-event-handlers","title":"Registering Event Handlers","text":"<pre><code>local handlerId = opengothic.events.register(\"eventName\", function(...)\n    -- Handle the event\n    return false\nend)\n</code></pre> <ul> <li><code>opengothic.events.register(eventName, callback) -&gt; handlerId|nil</code></li> <li><code>opengothic.events.unregister(eventName, handlerId) -&gt; boolean</code></li> </ul> <p>Multiple handlers can be registered for the same event. They are called in registration order until one returns <code>true</code>.</p>"},{"location":"api-reference/events/#handler-return-semantics","title":"Handler Return Semantics","text":"<ul> <li>Blocking hooks: returning <code>true</code> blocks the default engine behavior.</li> <li>Notification hooks: the engine ignores the final handled state, but returning <code>true</code> still stops later Lua handlers in the same event chain.</li> <li>For composable observer-style handlers, return <code>false</code>/<code>nil</code>.</li> </ul>"},{"location":"api-reference/events/#lifecycle-events","title":"Lifecycle Events","text":""},{"location":"api-reference/events/#onstartgame","title":"<code>onStartGame</code>","text":"<p>Called when a new game is started.</p> <ul> <li><code>worldName</code> (string): The name of the starting world.</li> </ul> <pre><code>opengothic.events.register(\"onStartGame\", function(worldName)\n    print(\"Starting new game in \" .. worldName)\nend)\n</code></pre>"},{"location":"api-reference/events/#onloadgame","title":"<code>onLoadGame</code>","text":"<p>Called when a saved game is loaded.</p> <ul> <li><code>savegameName</code> (string): The name of the save file.</li> </ul> <pre><code>opengothic.events.register(\"onLoadGame\", function(savegameName)\n    print(\"Loading save: \" .. savegameName)\nend)\n</code></pre>"},{"location":"api-reference/events/#onsavegame","title":"<code>onSaveGame</code>","text":"<p>Called when the game is saved.</p> <ul> <li><code>slotName</code> (string): The save slot identifier.</li> <li><code>userName</code> (string): The user-provided save name.</li> </ul> <pre><code>opengothic.events.register(\"onSaveGame\", function(slotName, userName)\n    print(\"Saving to \" .. slotName .. \": \" .. userName)\nend)\n</code></pre>"},{"location":"api-reference/events/#onworldloaded","title":"<code>onWorldLoaded</code>","text":"<p>Called after the world has finished loading. This is the ideal place to initialize world-dependent systems.</p> <p>Parameters: None</p> <pre><code>opengothic.events.register(\"onWorldLoaded\", function()\n    print(\"World loaded!\")\nend)\n</code></pre>"},{"location":"api-reference/events/#onstartloading","title":"<code>onStartLoading</code>","text":"<p>Called when a loading screen begins.</p> <p>Parameters: None</p>"},{"location":"api-reference/events/#onsessionexit","title":"<code>onSessionExit</code>","text":"<p>Called when the game session is ending (returning to menu).</p> <p>Parameters: None</p>"},{"location":"api-reference/events/#onsettingschanged","title":"<code>onSettingsChanged</code>","text":"<p>Called when game settings are modified.</p> <p>Parameters: None</p>"},{"location":"api-reference/events/#onupdate","title":"<code>onUpdate</code>","text":"<p>Called once per script update tick while a game session is active.</p> <ul> <li><code>dt</code> (number): Delta time in seconds.</li> </ul> <pre><code>opengothic.events.register(\"onUpdate\", function(dt)\n    return false\nend)\n</code></pre>"},{"location":"api-reference/events/#ongameminutechanged","title":"<code>onGameMinuteChanged</code>","text":"<p>Called when in-game time advances to a new minute.</p> <ul> <li><code>day</code> (number): Current in-game day.</li> <li><code>hour</code> (number): Current in-game hour.</li> <li><code>minute</code> (number): Current in-game minute.</li> </ul> <pre><code>opengothic.events.register(\"onGameMinuteChanged\", function(day, hour, minute)\n    print(\"Game time: day \" .. day .. \", \" .. hour .. \":\" .. minute)\n    return false\nend)\n</code></pre>"},{"location":"api-reference/events/#npc-events","title":"NPC Events","text":""},{"location":"api-reference/events/#onnpcspawn","title":"<code>onNpcSpawn</code>","text":"<p>Called when an NPC is spawned into the world.</p> <ul> <li><code>npc</code> (Npc): The spawned NPC.</li> </ul> <pre><code>opengothic.events.register(\"onNpcSpawn\", function(npc)\n    print(npc:displayName() .. \" has spawned\")\nend)\n</code></pre>"},{"location":"api-reference/events/#onnpcremove","title":"<code>onNpcRemove</code>","text":"<p>Called when an NPC is removed from the world.</p> <ul> <li><code>npc</code> (Npc): The NPC being removed.</li> </ul>"},{"location":"api-reference/events/#onnpctakedamage","title":"<code>onNpcTakeDamage</code>","text":"<p>Called when an NPC takes damage. Return <code>true</code> to prevent the default damage.</p> <ul> <li><code>victim</code> (Npc): The NPC taking damage.</li> <li><code>attacker</code> (Npc): The NPC dealing damage.</li> <li><code>isSpell</code> (boolean): Whether the damage is from a spell.</li> <li><code>spellId</code> (number): The spell ID if <code>isSpell</code> is true.</li> </ul> <pre><code>opengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, isSpell, spellId)\n    if victim:isPlayer() then\n        print(\"Player took damage from \" .. attacker:displayName())\n    end\nend)\n</code></pre>"},{"location":"api-reference/events/#onnpcdeath","title":"<code>onNpcDeath</code>","text":"<p>Called when an NPC dies or is knocked unconscious. Return <code>true</code> to block the default death/KO handling.</p> <ul> <li><code>victim</code> (Npc): The NPC that died/fell unconscious.</li> <li><code>killer</code> (Npc or nil): The NPC responsible (may be nil).</li> <li><code>isDeath</code> (boolean): <code>true</code> if death, <code>false</code> if unconscious.</li> </ul> <pre><code>opengothic.events.register(\"onNpcDeath\", function(victim, killer, isDeath)\n    if isDeath then\n        print(victim:displayName() .. \" has died\")\n    else\n        print(victim:displayName() .. \" was knocked out\")\n    end\nend)\n</code></pre>"},{"location":"api-reference/events/#onnpcperception","title":"<code>onNpcPerception</code>","text":"<p>Called when an NPC perceives something. Use <code>opengothic.CONSTANTS.PercType</code> to identify perception types. Return <code>true</code> to block default handling.</p> <ul> <li><code>npc</code> (Npc): The NPC doing the perceiving.</li> <li><code>other</code> (Npc): The perceived NPC.</li> <li><code>percType</code> (number): The type of perception (see PercType constants).</li> </ul> <pre><code>opengothic.events.register(\"onNpcPerception\", function(npc, other, percType)\n    local PercType = opengothic.CONSTANTS.PercType\n    if percType == PercType.PERC_ASSESSENEMY then\n        print(npc:displayName() .. \" spotted an enemy: \" .. other:displayName())\n    end\nend)\n</code></pre>"},{"location":"api-reference/events/#item-events","title":"Item Events","text":""},{"location":"api-reference/events/#onitempickup","title":"<code>onItemPickup</code>","text":"<p>Called when an NPC picks up an item. Return <code>true</code> to block the pickup.</p> <ul> <li><code>npc</code> (Npc): The NPC picking up the item.</li> <li><code>item</code> (Item): The item being picked up.</li> </ul> <pre><code>opengothic.events.register(\"onItemPickup\", function(npc, item)\n    if npc:isPlayer() then\n        print(\"Picked up: \" .. item:displayName())\n    end\nend)\n</code></pre>"},{"location":"api-reference/events/#ondropitem","title":"<code>onDropItem</code>","text":"<p>Called when an NPC drops an item. Return <code>true</code> to block the drop.</p> <ul> <li><code>npc</code> (Npc): The NPC dropping the item.</li> <li><code>itemId</code> (number): The instance ID of the item.</li> <li><code>count</code> (number): The number of items dropped.</li> </ul>"},{"location":"api-reference/events/#onuseitem","title":"<code>onUseItem</code>","text":"<p>Called when an NPC uses an item (potions, food, etc.). Return <code>true</code> to block default item use.</p> <ul> <li><code>npc</code> (Npc): The NPC using the item.</li> <li><code>item</code> (Item): The item being used.</li> </ul> <pre><code>opengothic.events.register(\"onUseItem\", function(npc, item)\n    print(npc:displayName() .. \" used \" .. item:displayName())\nend)\n</code></pre>"},{"location":"api-reference/events/#onequip","title":"<code>onEquip</code>","text":"<p>Called when an NPC equips an item. Return <code>true</code> to block equip.</p> <ul> <li><code>npc</code> (Npc): The NPC equipping the item.</li> <li><code>item</code> (Item): The item being equipped.</li> </ul>"},{"location":"api-reference/events/#onunequip","title":"<code>onUnequip</code>","text":"<p>Called when an NPC unequips an item. Return <code>true</code> to block unequip.</p> <ul> <li><code>npc</code> (Npc): The NPC unequipping the item.</li> <li><code>item</code> (Item): The item being unequipped.</li> </ul>"},{"location":"api-reference/events/#combat-events","title":"Combat Events","text":""},{"location":"api-reference/events/#ondrawweapon","title":"<code>onDrawWeapon</code>","text":"<p>Called when an NPC draws a weapon. Return <code>true</code> to block draw.</p> <ul> <li><code>npc</code> (Npc): The NPC drawing the weapon.</li> <li><code>weaponType</code> (number): The type of weapon drawn.</li> </ul>"},{"location":"api-reference/events/#oncloseweapon","title":"<code>onCloseWeapon</code>","text":"<p>Called when an NPC sheathes their weapon. Return <code>true</code> to block sheath/close.</p> <ul> <li><code>npc</code> (Npc): The NPC sheathing the weapon.</li> </ul>"},{"location":"api-reference/events/#onspellcast","title":"<code>onSpellCast</code>","text":"<p>Called when a spell is cast. Return <code>true</code> to block the cast.</p> <ul> <li><code>caster</code> (Npc): The NPC casting the spell.</li> <li><code>target</code> (Npc or nil): The target of the spell (may be nil).</li> <li><code>spellId</code> (number): The ID of the spell being cast.</li> </ul> <pre><code>opengothic.events.register(\"onSpellCast\", function(caster, target, spellId)\n    print(caster:displayName() .. \" cast spell \" .. spellId)\nend)\n</code></pre>"},{"location":"api-reference/events/#interaction-events","title":"Interaction Events","text":""},{"location":"api-reference/events/#onopen","title":"<code>onOpen</code>","text":"<p>Called when an NPC opens an interactive object (chest, door, etc.). Return <code>true</code> to block open.</p> <ul> <li><code>npc</code> (Npc): The NPC opening the object.</li> <li><code>interactive</code> (Interactive): The object being opened.</li> </ul>"},{"location":"api-reference/events/#onransack","title":"<code>onRansack</code>","text":"<p>Called when the player loots an unconscious/dead NPC. Return <code>true</code> to block ransacking.</p> <ul> <li><code>player</code> (Npc): The player doing the looting.</li> <li><code>target</code> (Npc): The NPC being looted.</li> </ul>"},{"location":"api-reference/events/#ondialogstart","title":"<code>onDialogStart</code>","text":"<p>Called when a dialog begins. Return <code>true</code> to block dialog start.</p> <ul> <li><code>npc</code> (Npc): The NPC being talked to.</li> <li><code>player</code> (Npc): The player character.</li> </ul> <pre><code>opengothic.events.register(\"onDialogStart\", function(npc, player)\n    print(\"Starting dialog with \" .. npc:displayName())\nend)\n</code></pre>"},{"location":"api-reference/events/#ondialogoption","title":"<code>onDialogOption</code>","text":"<p>Called for each dialog option before it is shown. Return <code>true</code> to hide the option.</p> <ul> <li><code>npc</code> (Npc): The NPC being talked to.</li> <li><code>player</code> (Npc): The player character.</li> <li><code>infoName</code> (string): The Daedalus symbol name of the dialog option (e.g., <code>\"INFO_DIEGO_HALLO\"</code>).</li> </ul> <pre><code>-- Hide a specific quest dialog option outside of night hours\nopengothic.events.register(\"onDialogOption\", function(npc, player, infoName)\n    if not opengothic.dialog.isOption(infoName) then\n        return false\n    end\n\n    if infoName == \"INFO_NIGHTQUEST_START\" then\n        local world = opengothic.world()\n        if not world:isTime(20, 0, 6, 0) then\n            return true  -- Hide this option\n        end\n    end\n    return false  -- Show option\nend)\n</code></pre> <p>Use cases: - Time-gated quest options - Conditional dialog based on player state - Dynamic dialog filtering based on game progress</p> <p>See the Dialog Time Windows Tutorial for complete examples.</p>"},{"location":"api-reference/events/#onmobinteract","title":"<code>onMobInteract</code>","text":"<p>Called when an NPC interacts with a mob (usable object). Return <code>true</code> to block interaction.</p> <ul> <li><code>npc</code> (Npc): The NPC interacting.</li> <li><code>mob</code> (Interactive): The interactive object.</li> </ul>"},{"location":"api-reference/events/#ontrade","title":"<code>onTrade</code>","text":"<p>Called during a trade transaction. Return <code>true</code> to block the trade action.</p> <ul> <li><code>buyer</code> (Npc): The NPC buying.</li> <li><code>seller</code> (Npc): The NPC selling.</li> <li><code>itemId</code> (number): The instance ID of the item.</li> <li><code>count</code> (number): The number of items.</li> <li><code>isBuying</code> (boolean): <code>true</code> if player is buying, <code>false</code> if selling.</li> </ul> <pre><code>opengothic.events.register(\"onTrade\", function(buyer, seller, itemId, count, isBuying)\n    if isBuying then\n        print(\"Bought \" .. count .. \" items\")\n    else\n        print(\"Sold \" .. count .. \" items\")\n    end\nend)\n</code></pre>"},{"location":"api-reference/events/#movement-events","title":"Movement Events","text":""},{"location":"api-reference/events/#onjump","title":"<code>onJump</code>","text":"<p>Called when an NPC jumps. Return <code>true</code> to block jump.</p> <ul> <li><code>npc</code> (Npc): The NPC that jumped.</li> </ul>"},{"location":"api-reference/events/#onswimstart","title":"<code>onSwimStart</code>","text":"<p>Called when an NPC starts swimming.</p> <ul> <li><code>npc</code> (Npc): The NPC that started swimming.</li> </ul>"},{"location":"api-reference/events/#onswimend","title":"<code>onSwimEnd</code>","text":"<p>Called when an NPC stops swimming.</p> <ul> <li><code>npc</code> (Npc): The NPC that stopped swimming.</li> </ul>"},{"location":"api-reference/events/#ondivestart","title":"<code>onDiveStart</code>","text":"<p>Called when an NPC starts diving underwater.</p> <ul> <li><code>npc</code> (Npc): The NPC that started diving.</li> </ul>"},{"location":"api-reference/events/#ondiveend","title":"<code>onDiveEnd</code>","text":"<p>Called when an NPC surfaces from diving.</p> <ul> <li><code>npc</code> (Npc): The NPC that surfaced.</li> </ul>"},{"location":"api-reference/globals/","title":"Global Functions","text":"<p>These functions are available directly under the <code>opengothic</code> global table.</p>"},{"location":"api-reference/globals/#opengothicworld","title":"<code>opengothic.world()</code>","text":"<p>Returns the current <code>World</code> object. The World object is your primary entry point for finding objects and changing global world state.</p> <ul> <li>Returns: A <code>World</code> object, or <code>nil</code> if no game session is active.</li> </ul> <pre><code>local world = opengothic.world()\nif world then\n    -- Do something with the world\n    local time_h, time_m = world:time()\n    print(\"The time is \" .. time_h .. \":\" .. time_m)\nend\n</code></pre>"},{"location":"api-reference/globals/#opengothicplayer","title":"<code>opengothic.player()</code>","text":"<p>A convenience function to get the player's <code>Npc</code> object.</p> <ul> <li>Returns: The player's <code>Npc</code> object, or <code>nil</code> if no game session is active.</li> </ul> <pre><code>local player = opengothic.player()\nif player then\n    print(\"Player's name is \" .. player:displayName())\nend\n</code></pre>"},{"location":"api-reference/globals/#opengothicprintmessagemessage","title":"<code>opengothic.printMessage(message)</code>","text":"<p>Shows a message through the game's in-world/message UI channel.</p> <ul> <li><code>message</code> (string): The message to print.</li> </ul> <pre><code>local level = opengothic.player():level()\nopengothic.printMessage(\"Player level is: \" .. level)\n</code></pre> <p>For developer/test logs, prefer Lua's global <code>print(...)</code>, which writes to script log/stdout.</p>"},{"location":"api-reference/globals/#opengothicprintscreenmessage-x-y-time-font","title":"<code>opengothic.printScreen(message, x, y, [time], [font])</code>","text":"<p>Displays a message at a specific screen position. Useful for custom HUD elements, damage numbers, or notifications.</p> <ul> <li><code>message</code> (string): The text to display.</li> <li><code>x</code> (number): Horizontal position (0-100 percent, or -1 to center).</li> <li><code>y</code> (number): Vertical position (0-100 percent, or -1 to center).</li> <li><code>time</code> (number, optional): Display duration in seconds. Default: 5.</li> <li><code>font</code> (string, optional): Font name. Default: <code>\"font_old_10_white.tga\"</code>.</li> </ul> <pre><code>-- Display centered message for 3 seconds\nopengothic.printScreen(\"Level Up!\", -1, -1, 3)\n\n-- Display at top-left corner\nopengothic.printScreen(\"Score: 100\", 5, 5, 2)\n\n-- Display at bottom-center\nopengothic.printScreen(\"Press E to interact\", -1, 90, 4)\n</code></pre>"},{"location":"api-reference/globals/#opengothicresolvesymbolname","title":"<code>opengothic.resolve(symbolName)</code>","text":"<p>Finds the integer ID of a Daedalus symbol by its name. This is useful when you need to pass an instance ID to a function, such as when spawning an NPC or item.</p> <p>This lookup requires an active game world/session (the symbol table comes from the loaded <code>GameScript</code>).</p> <ul> <li><code>symbolName</code> (string): The name of the Daedalus instance (e.g., <code>\"PC_HERO\"</code>, <code>\"ItMw_1H_Sword\"</code>).</li> <li>Returns: The integer ID of the symbol, or <code>nil</code> if not found (or if no world is loaded).</li> </ul> <pre><code>local world = opengothic.world()\nif world then\n    local swordId = opengothic.resolve(\"ItMw_1H_Sword\")\n    if swordId then\n        -- Now you can use this ID to add the item\n        opengothic.player():inventory():addItem(swordId, 1)\n    end\nend\n</code></pre>"},{"location":"api-reference/globals/#bridge-tables","title":"Bridge Tables","text":"<p>The following global tables expose Daedalus interop and VM bridge APIs:</p> <ul> <li><code>opengothic.daedalus</code></li> <li><code>opengothic.vm</code></li> </ul> <p>For full behavioral contracts, see Daedalus Bridge Contracts.</p>"},{"location":"api-reference/globals/#raw-bridge-apis","title":"Raw Bridge APIs","text":"<p>The raw bridge APIs are:</p> <ul> <li><code>opengothic.daedalus.get(...)</code></li> <li><code>opengothic.daedalus.set(...)</code></li> <li><code>opengothic.daedalus.call(...)</code></li> <li><code>opengothic.vm.callWithContext(...)</code></li> <li><code>opengothic.vm.registerExternal(...)</code></li> <li><code>opengothic.vm.getSymbol(...)</code></li> <li><code>opengothic.vm.enumerate(...)</code></li> </ul> <p>Use these for low-level interop and symbol access. They can raise Lua errors on invalid state/arguments. External-function passthrough is currently unsupported. For non-throwing behavior, prefer the safe wrappers below.</p>"},{"location":"api-reference/globals/#opengothicdaedalusgetsymbolname-index","title":"<code>opengothic.daedalus.get(symbolName, [index])</code>","text":"<p>Reads a Daedalus symbol value from the active session.</p> <ul> <li>Returns: symbol value or <code>nil</code>.</li> <li>Safe to call without world; returns <code>nil</code> when unavailable.</li> </ul>"},{"location":"api-reference/globals/#opengothicdaedalussetsymbolname-value-index","title":"<code>opengothic.daedalus.set(symbolName, value, [index])</code>","text":"<p>Writes a Daedalus symbol value.</p> <ul> <li>Raises on invalid symbol/type/no-world cases.</li> </ul>"},{"location":"api-reference/globals/#opengothicdaedaluscallfunctionname","title":"<code>opengothic.daedalus.call(functionName, ...)</code>","text":"<p>Calls a Daedalus function symbol.</p> <ul> <li>Returns function result for scalar return types.</li> <li>Raises on invalid symbol/no-world/unsupported argument type.</li> <li>Raises for external function symbols (current bridge limitation).</li> </ul>"},{"location":"api-reference/globals/#opengothicvmcallwithcontextfunctionname-context","title":"<code>opengothic.vm.callWithContext(functionName, context, ...)</code>","text":"<p>Calls a Daedalus function with explicit context keys (<code>self</code>, <code>other</code>, <code>victim</code>, <code>item</code>).</p> <ul> <li>Returns function result for scalar return types.</li> <li>Raises on invalid symbol/no-world/call failure.</li> <li>Raises for external function symbols (current bridge limitation).</li> </ul>"},{"location":"api-reference/globals/#opengothicvmregisterexternalname-fn","title":"<code>opengothic.vm.registerExternal(name, fn)</code>","text":"<p>Registers a Lua callback as a Daedalus external.</p> <ul> <li>Callback is currently invoked with no positional arguments.</li> <li>Numeric return value is passed back to Daedalus.</li> </ul>"},{"location":"api-reference/globals/#opengothicvmgetsymbolname","title":"<code>opengothic.vm.getSymbol(name)</code>","text":"<p>Returns metadata table for a Daedalus symbol, or <code>nil</code>.</p>"},{"location":"api-reference/globals/#opengothicvmenumerateclassname-callback","title":"<code>opengothic.vm.enumerate(className, callback)</code>","text":"<p>Enumerates symbols, optionally filtered by parent class name.</p> <ul> <li>Callback gets <code>{ name, index }</code>.</li> <li>Return <code>false</code> from callback to stop.</li> </ul>"},{"location":"api-reference/globals/#opengothicdaedalustrycallfunctionname","title":"<code>opengothic.daedalus.tryCall(functionName, ...)</code>","text":"<p>Non-throwing wrapper around <code>opengothic.daedalus.call(...)</code>.</p> <ul> <li>Returns:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, err</code></li> </ul> <pre><code>local ok, result, err = opengothic.daedalus.tryCall(\"B_GivePlayerXP\", 100)\nif not ok then\n    print(\"tryCall failed: \" .. tostring(err))\nend\n</code></pre>"},{"location":"api-reference/globals/#opengothicdaedalustrysetsymbolname-value-index","title":"<code>opengothic.daedalus.trySet(symbolName, value, [index])</code>","text":"<p>Non-throwing wrapper around <code>opengothic.daedalus.set(...)</code>.</p> <ul> <li>Returns:</li> <li>success: <code>true, nil</code></li> <li>failure: <code>false, err</code></li> </ul> <pre><code>local ok, err = opengothic.daedalus.trySet(\"MY_QUEST_STATE\", 2)\nif not ok then\n    print(\"trySet failed: \" .. tostring(err))\nend\n</code></pre>"},{"location":"api-reference/globals/#opengothicdaedalusexistssymbolname","title":"<code>opengothic.daedalus.exists(symbolName)</code>","text":"<p>Checks whether a Daedalus symbol exists in the current session symbol table.</p> <ul> <li>Returns: <code>boolean</code></li> </ul> <pre><code>if opengothic.daedalus.exists(\"Npc_IsInState\") then\n    print(\"Symbol exists\")\nend\n</code></pre>"},{"location":"api-reference/globals/#opengothicvmcallcontextsafefunctionname-context","title":"<code>opengothic.vm.callContextSafe(functionName, context, ...)</code>","text":"<p>Non-throwing wrapper around <code>opengothic.vm.callWithContext(...)</code>.</p> <ul> <li><code>context</code> supports keys: <code>self</code>, <code>other</code>, <code>victim</code>, <code>item</code>.</li> <li>Returns:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, err</code></li> </ul> <pre><code>local ok, result, err = opengothic.vm.callContextSafe(\"ZS_Attack\", {\n    self = attacker,\n    other = target\n})\n</code></pre>"},{"location":"api-reference/globals/#opengothicvmcallselffunctionname-selfnpc","title":"<code>opengothic.vm.callSelf(functionName, selfNpc, ...)</code>","text":"<p>Convenience wrapper for <code>callContextSafe</code> with <code>{ self = selfNpc }</code>.</p> <ul> <li>Returns:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, err</code></li> </ul>"},{"location":"api-reference/globals/#opengothicvmcallselfotherfunctionname-selfnpc-othernpc","title":"<code>opengothic.vm.callSelfOther(functionName, selfNpc, otherNpc, ...)</code>","text":"<p>Convenience wrapper for <code>callContextSafe</code> with <code>{ self = selfNpc, other = otherNpc }</code>.</p> <ul> <li>Returns:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, err</code></li> </ul> <p>For full contracts and edge-case behavior of raw/safe bridge APIs, see Daedalus Bridge Contracts.</p>"},{"location":"api-reference/interactive/","title":"Interactive API","text":"<p>An <code>Interactive</code> object represents a \"mobsi\" in the world: chests, doors, switches, beds, thrones, and similar usable objects.</p>"},{"location":"api-reference/interactive/#interactivefocusname","title":"<code>interactive:focusName()</code>","text":"<ul> <li>Returns: <code>name</code> (string) - The display name shown when focused.</li> </ul>"},{"location":"api-reference/interactive/#interactiveschemename","title":"<code>interactive:schemeName()</code>","text":"<ul> <li>Returns: <code>name</code> (string) - Internal scheme/type name (for example <code>\"CHEST\"</code> or <code>\"DOOR\"</code>).</li> </ul>"},{"location":"api-reference/interactive/#interactivestate","title":"<code>interactive:state()</code>","text":"<ul> <li>Returns: <code>stateId</code> (number) - Current interactive state.</li> </ul>"},{"location":"api-reference/interactive/#interactiveiscontainer","title":"<code>interactive:isContainer()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this interactive acts as a container.</li> </ul>"},{"location":"api-reference/interactive/#interactiveisdoor","title":"<code>interactive:isDoor()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this interactive is a door.</li> </ul>"},{"location":"api-reference/interactive/#interactiveisladder","title":"<code>interactive:isLadder()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this interactive is a ladder.</li> </ul>"},{"location":"api-reference/interactive/#interactiveinventory","title":"<code>interactive:inventory()</code>","text":"<ul> <li>Returns: <code>Inventory</code> or <code>nil</code> - Inventory object for container interactives.</li> </ul>"},{"location":"api-reference/interactive/#interactiveneedtolockpickplayer","title":"<code>interactive:needToLockpick(player)</code>","text":"<ul> <li><code>player</code> (Npc): NPC checking lockpicking requirement.</li> <li>Returns: <code>boolean</code> - <code>true</code> if lockpicking is needed.</li> </ul>"},{"location":"api-reference/interactive/#interactiveiscracked","title":"<code>interactive:isCracked()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if the lock/container is already cracked.</li> </ul>"},{"location":"api-reference/interactive/#interactivesetascrackedcracked","title":"<code>interactive:setAsCracked(cracked)</code>","text":"<ul> <li><code>cracked</code> (boolean): New cracked-state value.</li> </ul>"},{"location":"api-reference/interactive/#interactiveistruedoornpc","title":"<code>interactive:isTrueDoor(npc)</code>","text":"<ul> <li><code>npc</code> (Npc): NPC context used for door checks.</li> <li>Returns: <code>boolean</code> - <code>true</code> if object behaves as a usable door for <code>npc</code>.</li> </ul>"},{"location":"api-reference/interactive/#interactiveattachnpc","title":"<code>interactive:attach(npc)</code>","text":"<ul> <li><code>npc</code> (Npc): NPC to attach to this interactive.</li> <li>Returns: <code>success</code> (boolean).</li> </ul>"},{"location":"api-reference/interactive/#interactivedetachnpc-quick","title":"<code>interactive:detach(npc, quick)</code>","text":"<ul> <li><code>npc</code> (Npc): NPC to detach.</li> <li><code>quick</code> (boolean): If <code>true</code>, force quicker detachment.</li> <li>Returns: <code>success</code> (boolean).</li> </ul>"},{"location":"api-reference/inventory/","title":"Inventory API","text":"<p>The <code>Inventory</code> object represents a collection of items. It can belong to an NPC or an interactive object like a chest. You can get an inventory object by calling <code>npc:inventory()</code> or <code>interactive:inventory()</code>.</p>"},{"location":"api-reference/inventory/#inventoryitems","title":"<code>inventory:items()</code>","text":"<p>Returns a list of all items in the inventory.</p> <ul> <li>Returns: <code>items</code> (table) - A list of <code>Item</code> objects.</li> </ul> <pre><code>local playerInv = opengothic.player():inventory()\nlocal items = playerInv:items()\n\nprint(\"Player has \" .. #items .. \" item stacks.\")\n\nfor i, item in ipairs(items) do\n    if item:isGold() then\n        print(\"Found \" .. item:count() .. \" ore!\")\n    end\nend\n</code></pre>"},{"location":"api-reference/inventory/#inventoryitemcountinstanceid","title":"<code>inventory:itemCount(instanceId)</code>","text":"<p>Counts the total number of a specific item in the inventory.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the item to count.</li> <li>Returns: <code>count</code> (number).</li> </ul> <pre><code>local playerInv = opengothic.player():inventory()\nlocal healingPotionId = opengothic.resolve(\"ITPO_HEAL\")\n\nlocal potionCount = playerInv:itemCount(healingPotionId)\nprint(\"Player has \" .. potionCount .. \" healing potions.\")\n</code></pre>"},{"location":"api-reference/inventory/#inventoryadditemitemid-count","title":"<code>inventory:addItem(itemId, count)</code>","text":"<p>Adds a new item stack to this inventory. This method allows you to add items directly to an inventory without using the Daedalus bridge.</p> <ul> <li><code>itemId</code> (number): The instance ID of the item to add (use <code>opengothic.resolve()</code> to get this).</li> <li><code>count</code> (number): The number of items to add.</li> <li>Returns: The newly added <code>Item</code> object, or <code>nil</code> if creation or adding failed.</li> </ul> <p>Note: This method throws an error if no world is currently loaded (e.g., during script initialization). Use it only inside event handlers or after a world has been loaded.</p> <pre><code>local playerInv = opengothic.player():inventory()\nlocal goldId = opengothic.resolve(\"ITMI_GOLD\")\n\nlocal newGold = playerInv:addItem(goldId, 100)\nif newGold then\n    opengothic.printMessage(\"Added 100 gold to inventory!\")\nend\n</code></pre>"},{"location":"api-reference/inventory/#inventorytransfersourceinventory-itemid-count-world","title":"<code>inventory:transfer(sourceInventory, itemId, count, world)</code>","text":"<p>Transfers a number of items from a source inventory to this inventory. This is a primitive - a low-level building block that gives you direct control. For most cases, using convenience methods like <code>Npc:giveItem()</code> or <code>Npc:takeAllFrom()</code> is recommended. See Architecture for more on the three-layer API design.</p> <ul> <li><code>sourceInventory</code> (Inventory): The inventory to take items from.</li> <li><code>itemId</code> (number): The instance ID of the item to transfer.</li> <li><code>count</code> (number): The number of items to transfer.</li> <li><code>world</code> (World): The current world object.</li> <li>Returns: <code>success</code> (boolean).</li> </ul> <pre><code>-- Low-level example: transfer 10 arrows from a chest to the player\nlocal world = opengothic.world()\nlocal chestId = opengothic.resolve(\"CHEST_01\")\nlocal chest = chestId and world:findInteractive(chestId)\nlocal player = opengothic.player()\n\nif world and chest and player then\n    local chestInv = chest:inventory()\n    local playerInv = player:inventory()\n    local arrowId = opengothic.resolve(\"ITRW_ARROW\")\n\n    -- Transfers 10 arrows from chest to player\n    playerInv:transfer(chestInv, arrowId, 10, world)\nend\n</code></pre>"},{"location":"api-reference/inventory/#inventorytransferallsourceinventory-world-includeequipped-includemission","title":"<code>inventory:transferAll(sourceInventory, [world], [includeEquipped], [includeMission])</code>","text":"<p>Transfers all matching stacks from a source inventory into this inventory.</p> <ul> <li><code>sourceInventory</code> (Inventory): Source inventory.</li> <li><code>world</code> (World, optional): World context. Defaults to the active world.</li> <li><code>includeEquipped</code> (boolean, optional): Include equipped stacks. Default: <code>false</code>.</li> <li><code>includeMission</code> (boolean, optional): Include mission stacks. Default: <code>true</code>.</li> <li>Returns: <code>items</code> (table) - A list of moved stack records:</li> <li><code>id</code> (number): Item class ID.</li> <li><code>count</code> (number): Stack count.</li> <li><code>name</code> (string): Display name.</li> </ul> <pre><code>local player = opengothic.player()\nlocal world = opengothic.world()\nlocal chest = world and world:findInteractive(opengothic.resolve(\"CHEST_01\"))\n\nif player and chest then\n    local moved = player:inventory():transferAll(chest:inventory(), world, false, true)\n    print(\"Moved stacks: \" .. tostring(#moved))\nend\n</code></pre> <p>See also: <code>opengothic.inventory</code> for namespace-level transfer wrappers.</p>"},{"location":"api-reference/item/","title":"Item API","text":"<p>The <code>Item</code> object represents an item instance, either in the world or in an inventory.</p>"},{"location":"api-reference/item/#itemdisplayname","title":"<code>item:displayName()</code>","text":"<ul> <li>Returns: <code>name</code> (string) - The item's display name.</li> </ul>"},{"location":"api-reference/item/#itemdescription","title":"<code>item:description()</code>","text":"<ul> <li>Returns: <code>description</code> (string) - The item's description text.</li> </ul>"},{"location":"api-reference/item/#itemposition","title":"<code>item:position()</code>","text":"<ul> <li>Returns: <code>x</code>, <code>y</code>, <code>z</code> (number, number, number) - Current world position. For inventory items this is usually <code>0, 0, 0</code>.</li> </ul>"},{"location":"api-reference/item/#itemclsid","title":"<code>item:clsId()</code>","text":"<ul> <li>Returns: <code>id</code> (number) - The item's class/instance ID. This is the same ID you get from <code>opengothic.resolve()</code>.</li> </ul>"},{"location":"api-reference/item/#counts-and-cost","title":"Counts and Cost","text":""},{"location":"api-reference/item/#itemcount","title":"<code>item:count()</code>","text":"<ul> <li>Returns: <code>count</code> (number) - The number of items in this stack. For non-stackable items, this is 1.</li> </ul>"},{"location":"api-reference/item/#itemsetcountn","title":"<code>item:setCount(n)</code>","text":"<ul> <li><code>n</code> (number): The new stack count for the item.</li> </ul>"},{"location":"api-reference/item/#itemcost","title":"<code>item:cost()</code>","text":"<ul> <li>Returns: <code>value</code> (number) - The base value of the item in ore.</li> </ul>"},{"location":"api-reference/item/#itemsellcost","title":"<code>item:sellCost()</code>","text":"<ul> <li>Returns: <code>value</code> (number) - The value of the item when sold by the player.</li> </ul>"},{"location":"api-reference/item/#itemweight","title":"<code>item:weight()</code>","text":"<ul> <li>Returns: <code>weight</code> (number) - The weight of a single item in the stack.</li> </ul>"},{"location":"api-reference/item/#item-properties-booleans","title":"Item Properties (Booleans)","text":""},{"location":"api-reference/item/#itemisequipped","title":"<code>item:isEquipped()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if currently equipped by the owner.</li> </ul>"},{"location":"api-reference/item/#itemismission","title":"<code>item:isMission()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a mission item.</li> </ul>"},{"location":"api-reference/item/#itemisgold","title":"<code>item:isGold()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is ore/gold.</li> </ul>"},{"location":"api-reference/item/#itemismulti","title":"<code>item:isMulti()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this item is stackable.</li> </ul>"},{"location":"api-reference/item/#itemis2h","title":"<code>item:is2H()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a two-handed weapon.</li> </ul>"},{"location":"api-reference/item/#itemiscrossbow","title":"<code>item:isCrossbow()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a crossbow.</li> </ul>"},{"location":"api-reference/item/#itemisring","title":"<code>item:isRing()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a ring.</li> </ul>"},{"location":"api-reference/item/#itemisarmor","title":"<code>item:isArmor()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is armor.</li> </ul>"},{"location":"api-reference/item/#itemisspell","title":"<code>item:isSpell()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a spell scroll.</li> </ul>"},{"location":"api-reference/item/#itemisrune","title":"<code>item:isRune()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a rune.</li> </ul>"},{"location":"api-reference/item/#itemisspellorrune","title":"<code>item:isSpellOrRune()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a spell or rune.</li> </ul>"},{"location":"api-reference/item/#itemisspellshoot","title":"<code>item:isSpellShoot()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this is a projectile spell item.</li> </ul> <pre><code>local item = opengothic.player():activeWeapon()\nif item and item:is2H() then\n    print(\"Player is using a two-handed weapon.\")\nend\n</code></pre>"},{"location":"api-reference/item/#combat-properties","title":"Combat Properties","text":""},{"location":"api-reference/item/#itemdamage","title":"<code>item:damage()</code>","text":"<ul> <li>Returns: <code>damage</code> (number) - The item's total damage value.</li> </ul>"},{"location":"api-reference/item/#itemdamagetype","title":"<code>item:damageType()</code>","text":"<ul> <li>Returns: <code>type</code> (number) - The bitmask of damage types. Use with <code>opengothic.CONSTANTS.Protection</code>.</li> </ul>"},{"location":"api-reference/item/#itemprotectionprotectionid","title":"<code>item:protection(protectionId)</code>","text":"<ul> <li><code>protectionId</code> (number): The ID of the protection type (<code>PROT_EDGE</code>, <code>PROT_FIRE</code>, etc.).</li> <li>Returns: <code>value</code> (number) - The protection this item provides against a damage type.</li> </ul> <pre><code>-- Find equipped armor by iterating the player's inventory\nlocal player = opengothic.player()\nlocal inv = player:inventory()\nfor _, item in ipairs(inv:items()) do\n    if item:isArmor() and item:isEquipped() then\n        local fireProt = item:protection(opengothic.CONSTANTS.Protection.PROT_FIRE)\n        print(\"Armor fire protection: \" .. fireProt)\n        break\n    end\nend\n</code></pre>"},{"location":"api-reference/item/#itemrange","title":"<code>item:range()</code>","text":"<ul> <li>Returns: <code>range</code> (number) - The range of the weapon.</li> </ul>"},{"location":"api-reference/item/#itemflags","title":"<code>item:flags()</code>","text":"<ul> <li>Returns: <code>flags</code> (number) - The raw item flags bitmask.</li> </ul>"},{"location":"api-reference/npc/","title":"Npc API","text":"<p>The <code>Npc</code> object represents a character in the world, including the player, allies, and enemies. It is one of the most important objects in the API.</p>"},{"location":"api-reference/npc/#npcdisplayname","title":"<code>npc:displayName()</code>","text":"<ul> <li>Returns: <code>name</code> (string) - The NPC's display name.</li> </ul>"},{"location":"api-reference/npc/#npcinstanceid","title":"<code>npc:instanceId()</code>","text":"<ul> <li>Returns: <code>id</code> (number) - The NPC's Daedalus instance symbol ID. Note: This is the type identifier, not a unique ID. All NPCs spawned from the same Daedalus instance (e.g., all \"SCAVENGER\" NPCs) share the same <code>instanceId()</code>.</li> </ul>"},{"location":"api-reference/npc/#npcworld","title":"<code>npc:world()</code>","text":"<ul> <li>Returns: <code>World</code> - The <code>World</code> object this NPC belongs to.</li> </ul>"},{"location":"api-reference/npc/#npcinventory","title":"<code>npc:inventory()</code>","text":"<ul> <li>Returns: <code>Inventory</code> - The NPC's <code>Inventory</code> object.</li> </ul>"},{"location":"api-reference/npc/#attributes-and-stats","title":"Attributes and Stats","text":""},{"location":"api-reference/npc/#npcattributeattributeid","title":"<code>npc:attribute(attributeId)</code>","text":"<p>Gets the value of a primary attribute. Use <code>opengothic.CONSTANTS.Attribute</code>.</p> <ul> <li><code>attributeId</code> (number): The ID of the attribute.</li> <li>Returns: <code>value</code> (number).</li> </ul> <pre><code>local player = opengothic.player()\nlocal str = player:attribute(opengothic.CONSTANTS.Attribute.ATR_STRENGTH)\nprint(\"Player strength: \" .. str)\n</code></pre>"},{"location":"api-reference/npc/#npcchangeattributeattributeid-delta-allowunconscious","title":"<code>npc:changeAttribute(attributeId, delta, allowUnconscious)</code>","text":"<p>Changes an attribute by a relative amount.</p> <ul> <li><code>attributeId</code> (number): The ID of the attribute.</li> <li><code>delta</code> (number): The amount to add or subtract.</li> <li><code>allowUnconscious</code> (boolean): If <code>true</code>, a negative change to health can cause unconsciousness but not death.</li> </ul> <pre><code>-- Give the player 10 mana\nlocal player = opengothic.player()\nplayer:changeAttribute(opengothic.CONSTANTS.Attribute.ATR_MANA, 10, true)\n</code></pre>"},{"location":"api-reference/npc/#npcsethealthvalue","title":"<code>npc:setHealth(value)</code>","text":"<p>Sets the NPC's health to an absolute value.</p> <ul> <li><code>value</code> (number): The new health value.</li> </ul>"},{"location":"api-reference/npc/#npclevel","title":"<code>npc:level()</code>","text":"<ul> <li>Returns: <code>level</code> (number)</li> </ul>"},{"location":"api-reference/npc/#npcexperience","title":"<code>npc:experience()</code>","text":"<ul> <li>Returns: <code>experience</code> (number)</li> </ul>"},{"location":"api-reference/npc/#npclearningpoints","title":"<code>npc:learningPoints()</code>","text":"<ul> <li>Returns: <code>lp</code> (number)</li> </ul>"},{"location":"api-reference/npc/#npcguild","title":"<code>npc:guild()</code>","text":"<ul> <li>Returns: <code>guildId</code> (number) - The NPC's guild ID.</li> </ul>"},{"location":"api-reference/npc/#npcprotectionprotectionid","title":"<code>npc:protection(protectionId)</code>","text":"<p>Gets the NPC's protection value against a specific damage type. Use <code>opengothic.CONSTANTS.Protection</code>.</p> <ul> <li><code>protectionId</code> (number): The ID of the protection type.</li> <li>Returns: <code>value</code> (number).</li> </ul> <pre><code>local fireProtection = opengothic.player():protection(opengothic.CONSTANTS.Protection.PROT_FIRE)\nprint(\"Player fire protection: \" .. fireProtection)\n</code></pre>"},{"location":"api-reference/npc/#npctalentskilltalentid","title":"<code>npc:talentSkill(talentId)</code>","text":"<p>Gets the NPC's skill level in a talent (e.g., One-Handed). Use <code>opengothic.CONSTANTS.Talent</code>.</p> <ul> <li><code>talentId</code> (number): The ID of the talent.</li> <li>Returns: <code>level</code> (number).</li> </ul>"},{"location":"api-reference/npc/#npcsettalentskilltalentid-level","title":"<code>npc:setTalentSkill(talentId, level)</code>","text":"<p>Sets the NPC's talent skill level.</p> <ul> <li><code>talentId</code> (number): The ID of the talent.</li> <li><code>level</code> (number): The new skill level.</li> </ul>"},{"location":"api-reference/npc/#npctalentvaluetalentid","title":"<code>npc:talentValue(talentId)</code>","text":"<p>Gets the NPC's raw value in a talent (e.g., Lockpicking value).</p> <ul> <li><code>talentId</code> (number): The ID of the talent.</li> <li>Returns: <code>value</code> (number).</li> </ul>"},{"location":"api-reference/npc/#npchitchancetalentid","title":"<code>npc:hitChance(talentId)</code>","text":"<p>Gets the NPC's hit chance for a given weapon talent.</p> <ul> <li><code>talentId</code> (number): The ID of the talent (<code>TALENT_1H</code>, <code>TALENT_2H</code>, etc.).</li> <li>Returns: <code>chance</code> (number) - The hit chance from 0 to 100.</li> </ul>"},{"location":"api-reference/npc/#state-and-position","title":"State and Position","text":""},{"location":"api-reference/npc/#npcisdead","title":"<code>npc:isDead()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC is dead.</li> </ul>"},{"location":"api-reference/npc/#npcisunconscious","title":"<code>npc:isUnconscious()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC is unconscious.</li> </ul>"},{"location":"api-reference/npc/#npcisdown","title":"<code>npc:isDown()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC is dead OR unconscious.</li> </ul>"},{"location":"api-reference/npc/#npcisplayer","title":"<code>npc:isPlayer()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if this NPC is the player.</li> </ul>"},{"location":"api-reference/npc/#npcistalking","title":"<code>npc:isTalking()</code>","text":"<ul> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC is currently in talking state.</li> </ul>"},{"location":"api-reference/npc/#npcbodystate","title":"<code>npc:bodyState()</code>","text":"<ul> <li>Returns: <code>state</code> (number) - The raw body state bitmask. Use <code>hasState</code> for easier checks.</li> </ul>"},{"location":"api-reference/npc/#npchasstatestateid","title":"<code>npc:hasState(stateId)</code>","text":"<ul> <li><code>stateId</code> (number): The body state to check. Use <code>opengothic.CONSTANTS.BodyState</code>.</li> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC has the specified state.</li> </ul> <pre><code>if someNpc:hasState(opengothic.CONSTANTS.BodyState.BS_SNEAK) then\n    print(someNpc:displayName() .. \" is sneaking!\")\nend\n</code></pre>"},{"location":"api-reference/npc/#npcposition","title":"<code>npc:position()</code>","text":"<ul> <li>Returns: <code>x</code> (number), <code>y</code> (number), <code>z</code> (number) - The NPC's world coordinates.</li> </ul>"},{"location":"api-reference/npc/#npcsetpositionx-y-z","title":"<code>npc:setPosition(x, y, z)</code>","text":"<p>Teleports the NPC to the specified world coordinates.</p> <ul> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The destination coordinates.</li> </ul>"},{"location":"api-reference/npc/#npcrotationy","title":"<code>npc:rotationY()</code>","text":"<ul> <li>Returns: <code>angle</code> (number) - The NPC's rotation on the Y-axis (facing direction).</li> </ul>"},{"location":"api-reference/npc/#npcrotation","title":"<code>npc:rotation()</code>","text":"<ul> <li>Returns: <code>angle</code> (number) - The NPC's full rotation value.</li> </ul>"},{"location":"api-reference/npc/#npcsetdirectionyangle","title":"<code>npc:setDirectionY(angle)</code>","text":"<ul> <li><code>angle</code> (number): The new Y-axis rotation.</li> </ul>"},{"location":"api-reference/npc/#npcwalkmode","title":"<code>npc:walkMode()</code>","text":"<ul> <li>Returns: <code>mode</code> (number) - The raw walk mode bitmask.</li> </ul>"},{"location":"api-reference/npc/#npcsetwalkmodemode","title":"<code>npc:setWalkMode(mode)</code>","text":"<ul> <li><code>mode</code> (number): The new walk mode. Use <code>opengothic.CONSTANTS.WalkBit</code>.</li> </ul> <pre><code>-- Force an NPC to run\nlocal world = opengothic.world()\nlocal npcId = opengothic.resolve(\"VLK_400_BUDDLER\")\nlocal someNpc = npcId and world and world:findNpc(npcId)\nif someNpc then\n    someNpc:setWalkMode(opengothic.CONSTANTS.WalkBit.WM_Run)\nend\n</code></pre>"},{"location":"api-reference/npc/#social-and-ai","title":"Social and AI","text":""},{"location":"api-reference/npc/#npcattitude","title":"<code>npc:attitude()</code>","text":"<ul> <li>Returns: <code>attitude</code> (number) - The NPC's attitude towards the player. See <code>opengothic.CONSTANTS.Attitude</code>.</li> </ul>"},{"location":"api-reference/npc/#npcsetattitudeattitude","title":"<code>npc:setAttitude(attitude)</code>","text":"<ul> <li><code>attitude</code> (number): The new attitude.</li> </ul>"},{"location":"api-reference/npc/#equipment-and-spells","title":"Equipment and Spells","text":""},{"location":"api-reference/npc/#npciteminstanceid","title":"<code>npc:item(instanceId)</code>","text":"<p>Gets a specific item from the NPC's inventory.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the item.</li> <li>Returns: <code>Item</code> object, or <code>nil</code> if not found.</li> </ul>"},{"location":"api-reference/npc/#npcactiveweapon","title":"<code>npc:activeWeapon()</code>","text":"<ul> <li>Returns: <code>Item</code> object representing the currently equipped weapon, or <code>nil</code>.</li> </ul>"},{"location":"api-reference/npc/#npcactivespell","title":"<code>npc:activeSpell()</code>","text":"<ul> <li>Returns: <code>spellId</code> (number) - The class ID of the active spell, or -1 if none.</li> </ul>"},{"location":"api-reference/npc/#ai-control","title":"AI Control","text":""},{"location":"api-reference/npc/#npcdistancetoother","title":"<code>npc:distanceTo(other)</code>","text":"<p>Calculates the distance to another NPC.</p> <ul> <li><code>other</code> (Npc): The other NPC.</li> <li>Returns: <code>distance</code> (number) - Distance in world units, or -1 if either NPC is invalid.</li> </ul> <pre><code>local player = opengothic.player()\nlocal dist = npc:distanceTo(player)\nif dist &lt; 1000 then\n    print(\"NPC is close to player\")\nend\n</code></pre>"},{"location":"api-reference/npc/#npcflee","title":"<code>npc:flee()</code>","text":"<p>Makes the NPC flee from their current threat. Pushes a flee action to the AI queue.</p> <pre><code>-- Make NPC run away\nnpc:flee()\n</code></pre>"},{"location":"api-reference/npc/#npcsettargetother","title":"<code>npc:setTarget(other)</code>","text":"<p>Sets the NPC's combat target.</p> <ul> <li><code>other</code> (Npc or nil): The target NPC, or <code>nil</code> to clear the target.</li> </ul> <pre><code>npc:setTarget(player)\nnpc:attack()\n</code></pre>"},{"location":"api-reference/npc/#npctarget","title":"<code>npc:target()</code>","text":"<p>Gets the NPC's current combat target.</p> <ul> <li>Returns: <code>Npc</code> or <code>nil</code>.</li> </ul> <pre><code>local target = npc:target()\nif target then\n    print(npc:displayName() .. \" targets \" .. target:displayName())\nend\n</code></pre>"},{"location":"api-reference/npc/#npcsetperceptiontimetimems","title":"<code>npc:setPerceptionTime(timeMs)</code>","text":"<p>Sets the NPC perception polling interval in milliseconds.</p> <ul> <li><code>timeMs</code> (number): Interval in milliseconds. Values below 0 are clamped to 0.</li> </ul> <pre><code>-- Poll perceptions more frequently while debugging\nnpc:setPerceptionTime(500)\n</code></pre>"},{"location":"api-reference/npc/#npcattack","title":"<code>npc:attack()</code>","text":"<p>Makes the NPC attack their current target. Pushes an attack action to the AI queue.</p> <pre><code>npc:setTarget(enemy)\nnpc:attack()\n</code></pre>"},{"location":"api-reference/npc/#npcclearai","title":"<code>npc:clearAI()</code>","text":"<p>Clears all pending AI actions from the NPC's action queue.</p> <pre><code>-- Stop current behavior and start fresh\nnpc:clearAI()\nnpc:flee()\n</code></pre>"},{"location":"api-reference/npc/#convenience-methods","title":"Convenience Methods","text":"<p>These methods are defined in <code>bootstrap.lua</code> and compose available scripting primitives.</p>"},{"location":"api-reference/npc/#npccalldaedalusfuncname","title":"<code>npc:callDaedalus(funcName, ...)</code>","text":"<p>Calls a Daedalus function with this NPC set as the <code>self</code> context.</p> <ul> <li><code>funcName</code> (string): The name of the Daedalus function to call.</li> <li><code>...</code>: Additional arguments to pass to the function.</li> <li>Returns: The return value from the Daedalus function.</li> </ul> <pre><code>local player = opengothic.player()\nplayer:callDaedalus(\"B_GivePlayerXP\", 100)\n</code></pre>"},{"location":"api-reference/npc/#npcgiveitemitemname-count","title":"<code>npc:giveItem(itemName, count)</code>","text":"<p>Adds items to the NPC inventory.</p> <ul> <li><code>itemName</code> (string): The name of the item instance (e.g., <code>\"ITMI_GOLD\"</code>).</li> <li><code>count</code> (number, optional): The number of items to give. Defaults to 1.</li> <li>Returns: <code>boolean</code> - <code>true</code> if successful.</li> </ul> <pre><code>local player = opengothic.player()\nplayer:giveItem(\"ITMI_GOLD\", 100)\nplayer:giveItem(\"ITAR_MIL_L\")\n</code></pre>"},{"location":"api-reference/npc/#npchasitemitemname-mincount","title":"<code>npc:hasItem(itemName, minCount)</code>","text":"<p>Checks if the NPC has at least a specified number of an item.</p> <ul> <li><code>itemName</code> (string): The name of the item instance.</li> <li><code>minCount</code> (number, optional): The minimum count required. Defaults to 1.</li> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC has at least <code>minCount</code> of the item.</li> </ul> <p>Notes: - Delegates to <code>opengothic.inventory.hasItem(...)</code> convenience helper.</p> <pre><code>local player = opengothic.player()\nif player:hasItem(\"ITKE_KEY_01\") then\n    print(\"Player has the key!\")\nend\n\nif player:hasItem(\"ITMI_GOLD\", 100) then\n    print(\"Player has enough gold\")\nend\n</code></pre>"},{"location":"api-reference/npc/#convenience-and-utility-methods","title":"Convenience and Utility Methods","text":"<p>These methods are available on <code>Npc</code> for common scripting tasks.</p>"},{"location":"api-reference/npc/#npctakeallfromsrcinventory-world-includeequipped-includemission","title":"<code>npc:takeAllFrom(srcInventory, [world], [includeEquipped], [includeMission])</code>","text":"<p>Transfers item stacks from <code>srcInventory</code> to this NPC's inventory.</p> <ul> <li><code>srcInventory</code> (Inventory): Source inventory.</li> <li><code>world</code> (World, optional): World context for transfer. Defaults to the NPC's world.</li> <li><code>includeEquipped</code> (boolean, optional): Include equipped items. Default: <code>false</code>.</li> <li><code>includeMission</code> (boolean, optional): Include mission items. Default: <code>true</code>.</li> <li>Returns: <code>transferredItems</code> (table) - A list of transferred stack records with:</li> <li><code>id</code> (number): Item class ID.</li> <li><code>count</code> (number): Transferred stack count.</li> <li><code>name</code> (string): Display name.</li> </ul> <pre><code>local player = opengothic.player()\nlocal chest = world:findInteractive(opengothic.resolve(\"CHEST_01\")) -- Assuming 'world' is available\nif chest then\n    local transferred = player:takeAllFrom(chest:inventory())\n    for _, itemRecord in ipairs(transferred) do\n        print(\"Took \" .. itemRecord.count .. \"x \" .. itemRecord.name .. \" (id=\" .. itemRecord.id .. \")\")\n    end\nend\n</code></pre>"},{"location":"api-reference/npc/#npcisinstanceinstancename","title":"<code>npc:isInstance(instanceName)</code>","text":"<p>Checks if this NPC matches a specific instance name. Uses <code>npc:instanceId()</code> and <code>opengothic.resolve()</code> primitives internally.</p> <ul> <li><code>instanceName</code> (string): The name of the instance to check (e.g., <code>\"PC_HERO\"</code>, <code>\"GRD_200_GUARD\"</code>).</li> <li>Returns: <code>boolean</code> - <code>true</code> if this NPC's instance ID matches the resolved name.</li> </ul> <pre><code>opengothic.events.register(\"onDialogStart\", function(npc, player)\n    if npc:isInstance(\"YOURSPECIALNPC\") then\n        -- This is a specific NPC\n        opengothic.printMessage(\"You found the special NPC!\")\n    end\n    return false\nend)\n</code></pre>"},{"location":"api-reference/npc/#npcissneaking","title":"<code>npc:isSneaking()</code>","text":"<p>Checks if this NPC is currently sneaking. Uses <code>npc:walkMode()</code> primitive internally.</p> <ul> <li>Returns: <code>boolean</code> - <code>true</code> if the NPC is sneaking.</li> </ul> <pre><code>local player = opengothic.player()\nif player:isSneaking() then\n    print(\"Player is sneaking\")\nend\n</code></pre>"},{"location":"api-reference/storage/","title":"Storage API","text":"<p>The storage system allows Lua scripts to persist data across game saves.</p>"},{"location":"api-reference/storage/#opengothicstorage","title":"<code>opengothic.storage</code>","text":"<p>A table for storing persistent data. Any data placed here is automatically saved and restored with the game.</p>"},{"location":"api-reference/storage/#supported-types","title":"Supported Types","text":"Type Example string <code>opengothic.storage.playerName = \"Hero\"</code> number <code>opengothic.storage.questProgress = 3</code> boolean <code>opengothic.storage.hasMetNpc = true</code>"},{"location":"api-reference/storage/#example","title":"Example","text":"<pre><code>-- Store data\nopengothic.storage.mymod_score = 100\nopengothic.storage.mymod_completed = true\n\n-- Retrieve data (with defaults for new games)\nlocal score = opengothic.storage.mymod_score or 0\nlocal done = opengothic.storage.mymod_completed or false\n</code></pre>"},{"location":"api-reference/storage/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Prefix keys with your mod name to avoid conflicts:    <pre><code>opengothic.storage.mymod_variable = value\n</code></pre></p> </li> <li> <p>Always provide defaults when reading:    <pre><code>local val = opengothic.storage.key or defaultValue\n</code></pre></p> </li> <li> <p>Keep data simple - avoid storing complex nested structures</p> </li> </ol>"},{"location":"api-reference/storage/#how-it-works","title":"How It Works","text":"<p>The storage system integrates with OpenGothic's save system to persist your data automatically.</p>"},{"location":"api-reference/storage/#saveload-flow","title":"Save/Load Flow","text":"<pre><code>sequenceDiagram\n    participant Mod as Your Mod\n    participant Storage as opengothic.storage\n    participant Engine as C++ Engine\n    participant File as Save File\n\n    Note over Mod,File: Saving\n    Mod-&gt;&gt;Storage: storage.myKey = \"value\"\n    Engine-&gt;&gt;Storage: _serializeStorage()\n    Storage--&gt;&gt;Engine: {myKey: \"s:value\"}\n    Engine-&gt;&gt;File: Write to game/lua\n\n    Note over Mod,File: Loading\n    Engine-&gt;&gt;Storage: clear storage table\n    File-&gt;&gt;Engine: Read game/lua\n    Engine-&gt;&gt;Storage: _deserializeStorage(data)\n    Storage--&gt;&gt;Mod: storage.myKey == \"value\"</code></pre>"},{"location":"api-reference/storage/#save-file-structure","title":"Save File Structure","text":"<p>Lua storage is saved as an optional entry in the save file zip:</p> <pre><code>savegame.zip\n\u251c\u2500\u2500 header\n\u251c\u2500\u2500 preview.png\n\u251c\u2500\u2500 game/session\n\u251c\u2500\u2500 game/camera\n\u251c\u2500\u2500 game/perc\n\u251c\u2500\u2500 game/quests\n\u251c\u2500\u2500 game/daedalus\n\u2514\u2500\u2500 game/lua          \u2190 Lua storage (may not exist in old saves)\n</code></pre>"},{"location":"api-reference/storage/#type-encoding","title":"Type Encoding","text":"<p>Values are encoded with type prefixes to preserve their original types:</p> Type Prefix Encoded Restored string <code>s:</code> <code>\"s:hello\"</code> <code>\"hello\"</code> number <code>n:</code> <code>\"n:42.5\"</code> <code>42.5</code> boolean <code>b:</code> <code>\"b:1\"</code> / <code>\"b:0\"</code> <code>true</code> / <code>false</code> <p>Unsupported types (tables, functions, userdata) are silently ignored during serialization.</p>"},{"location":"api-reference/storage/#backward-compatibility","title":"Backward Compatibility","text":"<p>When loading saves created before this feature was added, <code>opengothic.storage</code> will be an empty table. Scripts should always handle missing data gracefully by using the <code>or</code> pattern for default values.</p>"},{"location":"api-reference/world/","title":"World API","text":"<p>The <code>World</code> object is the main entry point for interacting with the game world as a whole. You can get the current world object by calling <code>opengothic.world()</code>.</p>"},{"location":"api-reference/world/#primitives","title":"Primitives","text":"<p>These methods are implemented in C++ and provide direct access to world functionality. They use numeric IDs (from <code>opengothic.resolve()</code>) and do not call Daedalus functions.</p>"},{"location":"api-reference/world/#worldtime","title":"<code>world:time()</code>","text":"<p>Gets the current in-game time.</p> <ul> <li>Returns: <code>hour</code> (number), <code>minute</code> (number)</li> </ul> <pre><code>local h, m = opengothic.world():time()\nopengothic.printMessage(\"Current time: \" .. h .. \":\" .. m)\n</code></pre>"},{"location":"api-reference/world/#worldistimestarthour-startmin-endhour-endmin","title":"<code>world:isTime(startHour, startMin, endHour, endMin)</code>","text":"<p>Checks if the current game time is within a specified range. Correctly handles overnight ranges (for example, <code>20:00</code> to <code>06:00</code>).</p> <ul> <li><code>startHour</code> (number): Start hour (0-23).</li> <li><code>startMin</code> (number): Start minute (0-59).</li> <li><code>endHour</code> (number): End hour (0-23).</li> <li><code>endMin</code> (number): End minute (0-59).</li> <li>Returns: <code>boolean</code> - <code>true</code> if the current time is within the range (inclusive start, exclusive end).</li> </ul> <pre><code>local world = opengothic.world()\n\nif world:isTime(22, 0, 6, 0) then\n    print(\"It's nighttime!\")\nend\n</code></pre>"},{"location":"api-reference/world/#worldsetdaytimehour-minute","title":"<code>world:setDayTime(hour, minute)</code>","text":"<p>Sets the current in-game time.</p> <ul> <li><code>hour</code> (number): The hour to set (0-23).</li> <li><code>minute</code> (number): The minute to set (0-59).</li> </ul> <pre><code>-- Set the time to midnight\nopengothic.world():setDayTime(0, 0)\n</code></pre>"},{"location":"api-reference/world/#worldday","title":"<code>world:day()</code>","text":"<p>Gets the current in-game day number.</p> <ul> <li>Returns: <code>day</code> (number)</li> </ul>"},{"location":"api-reference/world/#worldaddnpcinstanceid-waypoint","title":"<code>world:addNpc(instanceId, waypoint)</code>","text":"<p>Spawns an NPC at a specific waypoint.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the NPC to spawn (use <code>opengothic.resolve()</code> to get this).</li> <li><code>waypoint</code> (string): The name of the waypoint to spawn the NPC at (e.g., <code>\"WP_START\"</code>).</li> <li>Returns: The new <code>Npc</code> object, or <code>nil</code> if spawning failed.</li> </ul> <pre><code>local mudId = opengothic.resolve(\"PC_MUD\")\nif mudId then\n    local newMud = opengothic.world():addNpc(mudId, \"WP_CITY_CENTER\")\n    if newMud then\n        newMud:setAttitude(opengothic.CONSTANTS.Attitude.ATT_FRIENDLY)\n    end\nend\n</code></pre>"},{"location":"api-reference/world/#worldaddnpcatinstanceid-x-y-z","title":"<code>world:addNpcAt(instanceId, x, y, z)</code>","text":"<p>Spawns an NPC at a specific world coordinate.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the NPC.</li> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The world coordinates.</li> <li>Returns: The new <code>Npc</code> object, or <code>nil</code> if spawning failed.</li> </ul> <pre><code>local playerPos = { opengothic.player():position() }\nlocal wolfId = opengothic.resolve(\"WOLF\")\n-- Spawn a wolf 100 units in front of the player\nopengothic.world():addNpcAt(wolfId, playerPos[1] + 100, playerPos[2], playerPos[3])\n</code></pre>"},{"location":"api-reference/world/#worldremovenpcnpc","title":"<code>world:removeNpc(npc)</code>","text":"<p>Removes an NPC from the world.</p> <ul> <li><code>npc</code> (Npc): The NPC object to remove.</li> </ul>"},{"location":"api-reference/world/#worldadditeminstanceid-waypoint","title":"<code>world:addItem(instanceId, waypoint)</code>","text":"<p>Spawns an item in the world at a specific waypoint.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the item.</li> <li><code>waypoint</code> (string): The name of the waypoint.</li> <li>Returns: The new <code>Item</code> object, or <code>nil</code> on failure.</li> </ul>"},{"location":"api-reference/world/#worldadditematinstanceid-x-y-z","title":"<code>world:addItemAt(instanceId, x, y, z)</code>","text":"<p>Spawns an item at a specific world coordinate.</p> <ul> <li><code>instanceId</code> (number): The instance ID of the item.</li> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The world coordinates.</li> <li>Returns: The new <code>Item</code> object, or <code>nil</code> on failure.</li> </ul>"},{"location":"api-reference/world/#worldremoveitemitem","title":"<code>world:removeItem(item)</code>","text":"<p>Removes an item from the world.</p> <ul> <li><code>item</code> (Item): The item object to remove.</li> </ul>"},{"location":"api-reference/world/#worldfindnpcinstanceid-n","title":"<code>world:findNpc(instanceId, [n])</code>","text":"<p>Finds an NPC in the world by its instance ID.</p> <ul> <li><code>instanceId</code> (number): The instance ID to search for.</li> <li><code>n</code> (number, optional): The nth NPC to find (0-based). Defaults to 0. Useful if multiple NPCs have the same ID.</li> <li>Returns: An <code>Npc</code> object, or <code>nil</code> if not found.</li> </ul> <pre><code>local laresId = opengothic.resolve(\"PC_THIEF_LARES\")\nlocal lares = opengothic.world():findNpc(laresId)\nif lares then\n    -- Found him!\nend\n</code></pre>"},{"location":"api-reference/world/#worldfinditeminstanceid-n","title":"<code>world:findItem(instanceId, [n])</code>","text":"<p>Finds an item in the world by its instance ID.</p> <ul> <li><code>instanceId</code> (number): The instance ID to search for.</li> <li><code>n</code> (number, optional): The nth item to find (0-based). Defaults to 0.</li> <li>Returns: An <code>Item</code> object, or <code>nil</code> if not found.</li> </ul>"},{"location":"api-reference/world/#worldfindinteractiveinstanceid","title":"<code>world:findInteractive(instanceId)</code>","text":"<p>Finds an interactive object (mobsi) in the world by its instance ID.</p> <ul> <li><code>instanceId</code> (number): The instance ID to search for (e.g., <code>opengothic.resolve(\"MOBSI_CHEST_01\")</code>).</li> <li>Returns: An <code>Interactive</code> object, or <code>nil</code> if not found.</li> </ul>"},{"location":"api-reference/world/#worldplayer","title":"<code>world:player()</code>","text":"<p>Gets the player's <code>Npc</code> object. This is a shortcut for <code>opengothic.player()</code>.</p> <ul> <li>Returns: The player <code>Npc</code> object, or <code>nil</code>.</li> </ul>"},{"location":"api-reference/world/#worldplaysoundsoundname","title":"<code>world:playSound(soundName)</code>","text":"<p>Plays a sound effect globally.</p> <ul> <li><code>soundName</code> (string): The name of the sound effect file (without extension).</li> </ul> <pre><code>-- Play a magic sound\nopengothic.world():playSound(\"MFX_HEAL_HEAL\")\n</code></pre>"},{"location":"api-reference/world/#worldplayeffecteffectname-x-y-z","title":"<code>world:playEffect(effectName, x, y, z)</code>","text":"<p>Spawns a visual effect (VFX) at a specific world coordinate.</p> <ul> <li><code>effectName</code> (string): The name of the effect (e.g., <code>\"SpellFx_Lightning\"</code>).</li> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The world coordinates to spawn the effect at.</li> </ul>"},{"location":"api-reference/world/#worldspelldescspellid","title":"<code>world:spellDesc(spellId)</code>","text":"<p>Gets information about a spell.</p> <ul> <li><code>spellId</code> (number): The ID of the spell (from <code>item.clsId()</code> on a rune or scroll).</li> <li>Returns: A table with spell properties, or <code>nil</code>.</li> <li><code>damagePerLevel</code> (number)</li> <li><code>damageType</code> (number)</li> <li><code>spellType</code> (number)</li> <li><code>timePerMana</code> (number)</li> </ul> <pre><code>local fireboltId = opengothic.resolve(\"ITRU_FIREBOLT\")\nlocal spellInfo = opengothic.world():spellDesc(fireboltId)\nif spellInfo then\n    print(\"Firebolt damage type: \" .. spellInfo.damageType)\nend\n</code></pre>"},{"location":"api-reference/world/#worldfindnpcsinrangex-y-z-range","title":"<code>world:findNpcsInRange(x, y, z, range)</code>","text":"<p>Finds all NPCs within a specified radius of a world coordinate.</p> <ul> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The center point coordinates.</li> <li><code>range</code> (number): The search radius in world units.</li> <li>Returns: A table (array) of <code>Npc</code> objects found within range. Returns an empty table if none found. Note: Any NPC at the exact center point (distance = 0) is included.</li> </ul> <pre><code>local world = opengothic.world()\nlocal px, py, pz = opengothic.player():position()\n\n-- Find all NPCs within 1000 units of the player\nlocal nearbyNpcs = world:findNpcsInRange(px, py, pz, 1000)\nfor _, npc in ipairs(nearbyNpcs) do\n    print(\"Nearby: \" .. npc:displayName())\nend\n</code></pre>"},{"location":"api-reference/world/#worldfindnpcsnearnpc-range","title":"<code>world:findNpcsNear(npc, range)</code>","text":"<p>Finds all NPCs within a specified radius of another NPC.</p> <ul> <li><code>npc</code> (Npc): The NPC to search around.</li> <li><code>range</code> (number): The search radius in world units.</li> <li>Returns: A table (array) of <code>Npc</code> objects found within range. Note: The center <code>npc</code> itself is included in the results (distance = 0).</li> </ul> <pre><code>local world = opengothic.world()\nlocal player = opengothic.player()\n\nlocal nearby = world:findNpcsNear(player, 500)\nfor _, npc in ipairs(nearby) do\n    if not npc:isPlayer() then\n        print(\"Found: \" .. npc:displayName())\n    end\nend\n</code></pre>"},{"location":"api-reference/world/#worldfindnearestnpcoriginnpc-range","title":"<code>world:findNearestNpc(originNpc, range)</code>","text":"<p>Finds the nearest NPC around an origin NPC.</p> <ul> <li><code>originNpc</code> (Npc): The NPC used as search center.</li> <li><code>range</code> (number): Search radius in world units.</li> <li>Returns: The nearest <code>Npc</code>, or <code>nil</code> if none is found.</li> </ul> <p>Notes: - The <code>originNpc</code> itself is excluded from results. - Returns <code>nil</code> for invalid inputs (for example <code>range &lt;= 0</code>).</p> <pre><code>local world = opengothic.world()\nlocal player = opengothic.player()\nlocal nearest = world:findNearestNpc(player, 1500)\nif nearest then\n    print(\"Nearest NPC: \" .. nearest:displayName())\nend\n</code></pre>"},{"location":"api-reference/world/#worlddetectitemsinrangex-y-z-range","title":"<code>world:detectItemsInRange(x, y, z, range)</code>","text":"<p>Finds all world items within a specified radius of a world coordinate.</p> <ul> <li><code>x</code>, <code>y</code>, <code>z</code> (numbers): The center point coordinates.</li> <li><code>range</code> (number): The search radius in world units.</li> <li>Returns: A table (array) of <code>Item</code> objects found within range. Returns an empty table for invalid inputs or when no item is found.</li> </ul> <pre><code>local world = opengothic.world()\nlocal px, py, pz = opengothic.player():position()\n\nlocal nearbyItems = world:detectItemsInRange(px, py, pz, 1000)\nfor _, item in ipairs(nearbyItems) do\n    print(\"Nearby item: \" .. item:displayName())\nend\n</code></pre>"},{"location":"api-reference/world/#worlddetectitemsnearoriginnpc-range","title":"<code>world:detectItemsNear(originNpc, range)</code>","text":"<p>Finds all world items around an origin NPC.</p> <ul> <li><code>originNpc</code> (Npc): The NPC used as search center.</li> <li><code>range</code> (number): Search radius in world units.</li> <li>Returns: A table (array) of <code>Item</code> objects found within range. Returns an empty table for invalid inputs.</li> </ul> <pre><code>local world = opengothic.world()\nlocal player = opengothic.player()\n\nfor _, item in ipairs(world:detectItemsNear(player, 800)) do\n    print(\"Detected item: \" .. item:displayName())\nend\n</code></pre>"},{"location":"api-reference/world/#worldfindnearestitemoriginnpc-range","title":"<code>world:findNearestItem(originNpc, range)</code>","text":"<p>Finds the nearest world item around an origin NPC.</p> <ul> <li><code>originNpc</code> (Npc): The NPC used as search center.</li> <li><code>range</code> (number): Search radius in world units.</li> <li>Returns: The nearest <code>Item</code>, or <code>nil</code> if none is found.</li> </ul> <p>Notes: - Returns <code>nil</code> for invalid inputs (for example <code>range &lt;= 0</code>).</p> <pre><code>local world = opengothic.world()\nlocal player = opengothic.player()\nlocal nearestItem = world:findNearestItem(player, 1200)\nif nearestItem then\n    print(\"Nearest item: \" .. nearestItem:displayName())\nend\n</code></pre>"},{"location":"api-reference/world/#convenience-methods","title":"Convenience Methods","text":"<p>These methods are defined in <code>bootstrap.lua</code> and wrap world primitives with symbol-name resolution.</p>"},{"location":"api-reference/world/#worldinsertnpcnpcname-waypoint","title":"<code>world:insertNpc(npcName, waypoint)</code>","text":"<p>Spawns an NPC at a waypoint using a symbol name instead of a resolved ID.</p> <ul> <li><code>npcName</code> (string): The name of the NPC instance (e.g., <code>\"PC_HERO\"</code>).</li> <li><code>waypoint</code> (string): The name of the waypoint.</li> <li>Returns: The new <code>Npc</code> object, or <code>nil</code> if spawning failed.</li> </ul> <pre><code>local world = opengothic.world()\nlocal newNpc = world:insertNpc(\"GRD_200_GUARD\", \"WP_CITY_GATE\")\nif newNpc then\n    print(\"Spawned guard at city gate\")\nend\n</code></pre>"},{"location":"api-reference/world/#worldinsertitemitemname-waypoint","title":"<code>world:insertItem(itemName, waypoint)</code>","text":"<p>Spawns an item at a waypoint using a symbol name instead of a resolved ID.</p> <ul> <li><code>itemName</code> (string): The name of the item instance (e.g., <code>\"ITMI_GOLD\"</code>).</li> <li><code>waypoint</code> (string): The name of the waypoint.</li> <li>Returns: The new <code>Item</code> object, or <code>nil</code> if spawning failed.</li> </ul> <pre><code>local world = opengothic.world()\nlocal goldPile = world:insertItem(\"ITMI_GOLD\", \"WP_TREASURE_SPOT\")\n</code></pre> <p>See also: <code>opengothic.worldutil</code> for namespace-level world query wrappers.</p>"},{"location":"api-reference/helpers/ai/","title":"opengothic.ai","text":"<p>The <code>opengothic.ai</code> table provides high-level wrappers around NPC AI primitives.</p> <p>All action helpers follow this return pattern: - success: <code>true, nil</code> - failure: <code>false, \"error_code\"</code></p>"},{"location":"api-reference/helpers/ai/#opengothicaiattacktargetnpc-target","title":"<code>opengothic.ai.attackTarget(npc, target)</code>","text":"<p>Sets <code>target</code> and pushes an attack action for <code>npc</code>.</p> <ul> <li><code>npc</code> (Npc): Attacker.</li> <li><code>target</code> (Npc): Target NPC.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local ok, err = opengothic.ai.attackTarget(guard, player)\nif not ok then\n    print(\"attackTarget failed: \" .. err)\nend\n</code></pre>"},{"location":"api-reference/helpers/ai/#opengothicaifleenpc","title":"<code>opengothic.ai.flee(npc)</code>","text":"<p>Pushes a flee action for <code>npc</code>.</p> <ul> <li><code>npc</code> (Npc): NPC that should flee.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local ok, err = opengothic.ai.flee(npc)\n</code></pre>"},{"location":"api-reference/helpers/ai/#opengothicaifleefromnpc-target-opts","title":"<code>opengothic.ai.fleeFrom(npc, target, opts)</code>","text":"<p>Sets <code>target</code> and pushes a flee action for <code>npc</code> as one atomic helper.</p> <p>Optional <code>opts</code> fields: - <code>setRunMode</code> (boolean, default <code>true</code>): If enabled, tries to set run walk mode before fleeing. - <code>runMode</code> (number, optional): Explicit walk mode override.</p> <ul> <li><code>npc</code> (Npc): NPC that should flee.</li> <li><code>target</code> (Npc): NPC to flee from.</li> <li><code>opts</code> (table|nil): Optional behavior flags.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local ok, err = opengothic.ai.fleeFrom(scavenger, opengothic.player())\nif not ok then\n    print(\"fleeFrom failed: \" .. err)\nend\n</code></pre>"},{"location":"api-reference/helpers/ai/#opengothicairesetnpc","title":"<code>opengothic.ai.reset(npc)</code>","text":"<p>Clears queued AI and target state for <code>npc</code>.</p> <ul> <li><code>npc</code> (Npc): NPC to reset.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local ok, err = opengothic.ai.reset(npc)\n</code></pre>"},{"location":"api-reference/helpers/ai/#opengothicaiiscombatreadynpc","title":"<code>opengothic.ai.isCombatReady(npc)</code>","text":"<p>Checks if an NPC appears combat-ready.</p> <p>Current checks: - valid NPC userdata - not dead - not down</p> <ul> <li><code>npc</code> (Npc): NPC to test.</li> <li>Returns: <code>boolean</code></li> </ul> <pre><code>if opengothic.ai.isCombatReady(enemy) then\n    opengothic.ai.attackTarget(enemy, opengothic.player())\nend\n</code></pre>"},{"location":"api-reference/helpers/damage-calculator/","title":"opengothic.DamageCalculator","text":"<p>The <code>opengothic.DamageCalculator</code> table exposes combat-damage methods.</p>"},{"location":"api-reference/helpers/damage-calculator/#opengothicdamagecalculatorcalculateattacker-victim-isspell-spellid","title":"<code>opengothic.DamageCalculator.calculate(attacker, victim, isSpell, spellId)</code>","text":"<p>High-level helper that builds a damage array (including spell damage typing) and delegates to <code>damageValue(...)</code>.</p> <ul> <li><code>attacker</code> (Npc): Attacker NPC.</li> <li><code>victim</code> (Npc): Victim NPC.</li> <li><code>isSpell</code> (boolean): Spell-vs-melee/ranged mode.</li> <li><code>spellId</code> (number): Spell class ID for spell damage lookup.</li> <li>Returns: Result of <code>damageValue(...)</code>.</li> </ul> <pre><code>local value, hasHit = opengothic.DamageCalculator.calculate(attacker, victim, true, spellId)\nprint(\"Damage=\" .. tostring(value) .. \", hit=\" .. tostring(hasHit))\n</code></pre>"},{"location":"api-reference/helpers/damage-calculator/#opengothicdamagecalculatordamagetypemasknpc","title":"<code>opengothic.DamageCalculator.damageTypeMask(npc)</code>","text":"<p>Low-level primitive helper for damage-type mask extraction.</p> <ul> <li><code>npc</code> (Npc): NPC to inspect.</li> <li>Returns: <code>mask</code> (number)</li> </ul>"},{"location":"api-reference/helpers/damage-calculator/#opengothicdamagecalculatordamagevalueattacker-victim-isspell-damagetable","title":"<code>opengothic.DamageCalculator.damageValue(attacker, victim, isSpell, damageTable)</code>","text":"<p>Low-level primitive damage evaluation helper.</p> <ul> <li><code>attacker</code> (Npc): Attacker NPC.</li> <li><code>victim</code> (Npc): Victim NPC.</li> <li><code>isSpell</code> (boolean): Spell-vs-melee/ranged mode.</li> <li><code>damageTable</code> (table): Damage values indexed by damage-type IDs.</li> <li>Returns: <code>value</code> (number), <code>hasHit</code> (boolean)</li> </ul> <pre><code>local dmg = {}\nfor i = 0, 7 do\n    dmg[i] = 0\nend\ndmg[0] = 30\n\nlocal value, hasHit = opengothic.DamageCalculator.damageValue(attacker, victim, false, dmg)\n</code></pre>"},{"location":"api-reference/helpers/dialog/","title":"opengothic.dialog","text":"<p>The <code>opengothic.dialog</code> table provides helpers for dialog checks and <code>onDialogOption</code> workflows.</p>"},{"location":"api-reference/helpers/dialog/#opengothicdialogisoptioninfoname","title":"<code>opengothic.dialog.isOption(infoName)</code>","text":"<p>Checks whether <code>infoName</code> is a valid dialog option symbol.</p> <ul> <li><code>infoName</code> (string): Candidate symbol name.</li> <li>Returns: <code>boolean</code></li> </ul> <p>Rules: - Must be a non-empty string. - Must start with <code>INFO_</code>. - Must resolve via <code>opengothic.resolve(...)</code>.</p> <pre><code>if opengothic.dialog.isOption(infoName) then\n    -- safe to apply option-specific logic\nend\n</code></pre>"},{"location":"api-reference/helpers/dialog/#opengothicdialogcantalktonpc","title":"<code>opengothic.dialog.canTalkTo(npc)</code>","text":"<p>Quick talkability guard.</p> <ul> <li><code>npc</code> (Npc): NPC to check.</li> <li>Returns: <code>boolean</code></li> </ul> <p>Current checks: - valid NPC - player exists - <code>npc</code> is not the player - not dead - not down - not currently talking</p>"},{"location":"api-reference/helpers/dialog/#opengothicdialogonoptioncallback","title":"<code>opengothic.dialog.onOption(callback)</code>","text":"<p>Registers a safe wrapper for <code>onDialogOption</code>.</p> <ul> <li><code>callback</code> (function): <code>callback(npc, player, infoName) -&gt; boolean</code></li> <li>Returns: <code>handlerId</code> (number or <code>nil</code>), <code>err</code> (<code>nil</code> or string)</li> </ul> <p>If the callback throws, the wrapper logs the error with <code>print(...)</code> and returns <code>false</code>.</p> <pre><code>local handlerId, err = opengothic.dialog.onOption(function(npc, player, infoName)\n    if infoName == \"INFO_SECRETQUEST_START\" then\n        return true\n    end\n    return false\nend)\n</code></pre>"},{"location":"api-reference/helpers/dialog/#opengothicdialogoffoptionhandlerid","title":"<code>opengothic.dialog.offOption(handlerId)</code>","text":"<p>Unregisters a handler previously returned by <code>dialog.onOption</code>.</p> <ul> <li><code>handlerId</code> (number): Registration ID.</li> <li>Returns: <code>boolean</code></li> </ul>"},{"location":"api-reference/helpers/dialog/#opengothicdialogblockoptioninfoname-blocked","title":"<code>opengothic.dialog.blockOption(infoName, [blocked])</code>","text":"<p>Adds or removes a static block rule for one dialog option.</p> <ul> <li><code>infoName</code> (string): Dialog option symbol (<code>INFO_*</code>).</li> <li><code>blocked</code> (boolean, optional): Defaults to <code>true</code>.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul>"},{"location":"api-reference/helpers/dialog/#opengothicdialogsetoptiontimewindowinfoname-starth-startm-endh-endm","title":"<code>opengothic.dialog.setOptionTimeWindow(infoName, startH, startM, endH, endM)</code>","text":"<p>Adds or updates a time-window rule for one dialog option.</p> <ul> <li><code>infoName</code> (string): Dialog option symbol (<code>INFO_*</code>).</li> <li><code>startH</code>, <code>startM</code>, <code>endH</code>, <code>endM</code> (number): Window boundaries.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <p>Behavior: - Option is shown inside the window. - Option is hidden outside the window.</p>"},{"location":"api-reference/helpers/dialog/#opengothicdialogclearoptiontimewindowinfoname","title":"<code>opengothic.dialog.clearOptionTimeWindow(infoName)</code>","text":"<p>Removes a time-window rule for one dialog option.</p> <ul> <li><code>infoName</code> (string): Dialog option symbol (<code>INFO_*</code>).</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul>"},{"location":"api-reference/helpers/effect/","title":"opengothic.effect","text":"<p>The <code>opengothic.effect</code> table provides convenience visual-effect helpers.</p>"},{"location":"api-reference/helpers/effect/#opengothiceffectplayeffectname-source-target","title":"<code>opengothic.effect.play(effectName, source, [target])</code>","text":"<p>Plays an effect at <code>source</code> position.</p> <ul> <li><code>effectName</code> (string): Effect identifier.</li> <li><code>source</code> (Npc): Source NPC.</li> <li><code>target</code> (Npc, optional): Reserved for compatibility, currently unused.</li> <li>Returns: <code>boolean</code> - <code>true</code> on successful world/position resolution.</li> </ul> <pre><code>local player = opengothic.player()\nif player then\n    opengothic.effect.play(\"spellFX_YOUREALLYGETME\", player)\nend\n</code></pre>"},{"location":"api-reference/helpers/inventory/","title":"opengothic.inventory","text":"<p>The <code>opengothic.inventory</code> table provides high-level wrappers around inventory transfer primitives.</p>"},{"location":"api-reference/helpers/inventory/#opengothicinventoryhasitemowner-itemref-mincount","title":"<code>opengothic.inventory.hasItem(owner, itemRef, [minCount])</code>","text":"<p>Checks whether an owner has at least <code>minCount</code> of an item.</p> <ul> <li><code>owner</code> (Npc or Inventory): NPC owner or direct inventory object.</li> <li><code>itemRef</code> (string or number): Item symbol name (<code>\"ITFO_APPLE\"</code>) or numeric item class ID.</li> <li><code>minCount</code> (number, optional): Minimum amount required. Default <code>1</code>.</li> <li>Returns: <code>boolean</code></li> </ul> <pre><code>local player = opengothic.player()\n\nif opengothic.inventory.hasItem(player, \"ITKE_KEY_01\") then\n    print(\"Player has the key\")\nend\n\nlocal inv = player:inventory()\nlocal appleId = opengothic.resolve(\"ITFO_APPLE\")\nif opengothic.inventory.hasItem(inv, appleId, 2) then\n    print(\"At least two apples in inventory\")\nend\n</code></pre>"},{"location":"api-reference/helpers/inventory/#opengothicinventorytransferalldstnpc-srcinv-opts","title":"<code>opengothic.inventory.transferAll(dstNpc, srcInv, [opts])</code>","text":"<p>Transfers all matching items from <code>srcInv</code> to <code>dstNpc:inventory()</code>.</p> <ul> <li><code>dstNpc</code> (Npc): Destination NPC.</li> <li><code>srcInv</code> (Inventory): Source inventory.</li> <li><code>opts</code> (table, optional):</li> <li><code>includeEquipped</code> (boolean, optional): Default <code>false</code>.</li> <li><code>includeMission</code> (boolean, optional): Default <code>true</code>.</li> <li>Returns: <code>items</code> (table), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local items, err = opengothic.inventory.transferAll(opengothic.player(), chest:inventory(), {\n    includeEquipped = false,\n    includeMission = true\n})\nif err then\n    print(\"Transfer failed: \" .. err)\nend\n</code></pre>"},{"location":"api-reference/helpers/inventory/#opengothicinventorytransferbypredicatedstnpc-srcinv-predicate-opts","title":"<code>opengothic.inventory.transferByPredicate(dstNpc, srcInv, predicate, [opts])</code>","text":"<p>Transfers only items for which <code>predicate(item)</code> returns <code>true</code>.</p> <ul> <li><code>dstNpc</code> (Npc): Destination NPC.</li> <li><code>srcInv</code> (Inventory): Source inventory.</li> <li><code>predicate</code> (function): Item filter callback.</li> <li><code>opts</code> (table, optional): Same as <code>transferAll</code>.</li> <li>Returns: <code>items</code> (table), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local items, err = opengothic.inventory.transferByPredicate(\n    opengothic.player(),\n    chest:inventory(),\n    function(item)\n        return item:isGold() or item:isRune()\n    end,\n    { includeMission = false }\n)\nif not err then\n    print(\"Filtered transfer stacks: \" .. tostring(#items))\nend\n</code></pre>"},{"location":"api-reference/helpers/quest/","title":"opengothic.quest","text":"<p>The <code>opengothic.quest</code> table provides quest-log helpers.</p> <p>These helpers use dedicated quest hooks exposed by the engine:</p> <ul> <li><code>opengothic._questCreateTopic</code></li> <li><code>opengothic._questSetTopicStatus</code></li> <li><code>opengothic._questAddEntry</code></li> </ul> <p>These helpers are non-throwing from Lua side: if a hook is unavailable they log to stdout with <code>print(...)</code> and return. They require an active world/session with a quest log.</p>"},{"location":"api-reference/helpers/quest/#opengothicqueststatus","title":"<code>opengothic.quest.STATUS</code>","text":"<p>Status constants:</p> Constant Value Description <code>FREE</code> <code>0</code> Quest is not active <code>RUNNING</code> <code>1</code> Quest is in progress <code>SUCCESS</code> <code>2</code> Quest completed successfully <code>FAILED</code> <code>3</code> Quest failed <code>OBSOLETE</code> <code>4</code> Quest is obsolete"},{"location":"api-reference/helpers/quest/#opengothicquestsection","title":"<code>opengothic.quest.SECTION</code>","text":"<p>Section constants:</p> Constant Value Description <code>MISSIONS</code> <code>0</code> Mission section <code>NOTES</code> <code>1</code> Notes section"},{"location":"api-reference/helpers/quest/#opengothicquestcreatetopicname-section","title":"<code>opengothic.quest.create(topicName, [section])</code>","text":"<p>Creates a new quest topic.</p> <ul> <li><code>topicName</code> (string): Topic identifier.</li> <li><code>section</code> (number, optional): One of <code>opengothic.quest.SECTION.*</code>. Default: <code>MISSIONS</code>.</li> <li>Returns: <code>nil</code></li> </ul> <pre><code>opengothic.quest.create(\"MY_QUEST\", opengothic.quest.SECTION.MISSIONS)\nopengothic.quest.create(\"MY_NOTE\", opengothic.quest.SECTION.NOTES)\n</code></pre>"},{"location":"api-reference/helpers/quest/#opengothicquestsetstatetopicname-status","title":"<code>opengothic.quest.setState(topicName, status)</code>","text":"<p>Sets topic status.</p> <ul> <li><code>topicName</code> (string): Topic identifier.</li> <li><code>status</code> (number or string): Status number or case-insensitive string key (for example <code>\"running\"</code>).</li> <li>Returns: <code>nil</code></li> </ul> <pre><code>opengothic.quest.setState(\"MY_QUEST\", opengothic.quest.STATUS.RUNNING)\nopengothic.quest.setState(\"MY_QUEST\", \"success\")\n</code></pre>"},{"location":"api-reference/helpers/quest/#opengothicquestaddentrytopicname-entrytext","title":"<code>opengothic.quest.addEntry(topicName, entryText)</code>","text":"<p>Adds a log entry to a topic.</p> <ul> <li><code>topicName</code> (string): Topic identifier.</li> <li><code>entryText</code> (string): Entry text.</li> <li>Returns: <code>nil</code></li> </ul> <pre><code>opengothic.quest.addEntry(\"MY_QUEST\", \"I should speak to the merchant.\")\n</code></pre>"},{"location":"api-reference/helpers/sound/","title":"opengothic.sound","text":"<p>The <code>opengothic.sound</code> table provides convenience sound helpers.</p>"},{"location":"api-reference/helpers/sound/#opengothicsoundplaysoundname","title":"<code>opengothic.sound.play(soundName)</code>","text":"<p>Plays a 2D/global sound.</p> <ul> <li><code>soundName</code> (string): Sound identifier.</li> <li>Returns: <code>boolean</code> - <code>true</code> when a world is active and the call is issued.</li> </ul> <pre><code>opengothic.sound.play(\"INV_CHANGE\")\n</code></pre>"},{"location":"api-reference/helpers/timer/","title":"opengothic.timer","text":"<p>The <code>opengothic.timer</code> table provides script-side scheduling helpers.</p> <p>Callbacks run under <code>pcall</code>, so one failing timer does not break other timers.</p>"},{"location":"api-reference/helpers/timer/#opengothictimerafterseconds-fn","title":"<code>opengothic.timer.after(seconds, fn)</code>","text":"<p>Schedules a one-shot callback after <code>seconds</code>.</p> <ul> <li><code>seconds</code> (number): Delay in real-time seconds (<code>&gt;= 0</code>).</li> <li><code>fn</code> (function): Callback <code>fn(timerId)</code>.</li> <li>Returns: <code>timerId</code> (number or <code>nil</code>), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local id, err = opengothic.timer.after(2.0, function(timerId)\n    print(\"One-shot timer fired: \" .. tostring(timerId))\nend)\n</code></pre>"},{"location":"api-reference/helpers/timer/#opengothictimereveryseconds-fn","title":"<code>opengothic.timer.every(seconds, fn)</code>","text":"<p>Schedules a repeating real-time callback.</p> <ul> <li><code>seconds</code> (number): Interval in seconds (<code>&gt; 0</code>).</li> <li><code>fn</code> (function): Callback <code>fn(timerId)</code>.</li> <li>Returns: <code>timerId</code> (number or <code>nil</code>), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local heartbeatId = opengothic.timer.every(1.0, function(timerId)\n    print(\"Tick \" .. tostring(timerId))\nend)\n</code></pre>"},{"location":"api-reference/helpers/timer/#opengothictimereverygameminutefn","title":"<code>opengothic.timer.everyGameMinute(fn)</code>","text":"<p>Schedules a callback for each in-game minute change.</p> <ul> <li><code>fn</code> (function): Callback <code>fn(timerId)</code>.</li> <li>Returns: <code>timerId</code> (number or <code>nil</code>), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local id = opengothic.timer.everyGameMinute(function()\n    local h, m = opengothic.world():time()\n    print(\"Game minute changed: \" .. h .. \":\" .. m)\nend)\n</code></pre>"},{"location":"api-reference/helpers/timer/#opengothictimercanceltimerid","title":"<code>opengothic.timer.cancel(timerId)</code>","text":"<p>Cancels a timer.</p> <ul> <li><code>timerId</code> (number): ID returned by a timer creation call.</li> <li>Returns: <code>boolean</code> (<code>true</code> if timer existed and was removed)</li> </ul> <pre><code>opengothic.timer.cancel(heartbeatId)\n</code></pre>"},{"location":"api-reference/helpers/ui/","title":"opengothic.ui","text":"<p>The <code>opengothic.ui</code> table provides wrappers for common message output patterns.</p>"},{"location":"api-reference/helpers/ui/#opengothicuinotifytext","title":"<code>opengothic.ui.notify(text)</code>","text":"<p>Shows a simple in-game message.</p> <ul> <li><code>text</code> (string): Message text.</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>local ok, err = opengothic.ui.notify(\"Quest updated\")\n</code></pre>"},{"location":"api-reference/helpers/ui/#opengothicuitoasttext-seconds-style","title":"<code>opengothic.ui.toast(text, [seconds], [style])</code>","text":"<p>Shows a positioned screen message via <code>opengothic.printScreen(...)</code>.</p> <ul> <li><code>text</code> (string): Message text.</li> <li><code>seconds</code> (number, optional): Duration in seconds.</li> <li><code>style</code> (table, optional):</li> <li><code>x</code> (number): X position (0-100 or <code>-1</code> center)</li> <li><code>y</code> (number): Y position (0-100 or <code>-1</code> center)</li> <li><code>font</code> (string): Font name</li> <li>Returns: <code>ok</code> (boolean), <code>err</code> (<code>nil</code> or string)</li> </ul> <pre><code>opengothic.ui.toast(\"Level up!\", 2.0, {\n    x = -1,\n    y = 82,\n    font = \"font_old_10_white.tga\"\n})\n</code></pre>"},{"location":"api-reference/helpers/ui/#opengothicuidebugtext","title":"<code>opengothic.ui.debug(text)</code>","text":"<p>Developer/test output helper. Writes to Lua <code>print(...)</code> (stdout/log), not in-world message UI.</p> <ul> <li><code>text</code> (any): Value to print. <code>nil</code> is ignored.</li> <li>Returns: none</li> </ul> <pre><code>opengothic.ui.debug(\"Loot pass started\")\nopengothic.ui.debug({}) -- prints table tostring()\n</code></pre>"},{"location":"api-reference/helpers/world/","title":"opengothic.worldutil","text":"<p>The <code>opengothic.worldutil</code> table provides convenience wrappers built on world, NPC, and item primitives.</p>"},{"location":"api-reference/helpers/world/#opengothicworldutilfindnearestnpcoriginnpc-range-predicate","title":"<code>opengothic.worldutil.findNearestNpc(originNpc, range, [predicate])</code>","text":"<p>Finds the nearest NPC around <code>originNpc</code>, with optional filtering.</p> <ul> <li><code>originNpc</code> (Npc): Origin NPC.</li> <li><code>range</code> (number): Search radius in world units.</li> <li><code>predicate</code> (function, optional): Filter callback <code>predicate(npc) -&gt; boolean</code>.</li> <li>Returns: <code>Npc</code> or <code>nil</code>.</li> </ul> <p>Behavior: - Without <code>predicate</code>, it uses the primitive <code>world:findNearestNpc(...)</code>. - With <code>predicate</code>, it scans <code>world:findNpcsNear(...)</code> and returns the nearest passing NPC. - The origin NPC is excluded.</p> <pre><code>local player = opengothic.player()\n\nlocal nearestAny = opengothic.worldutil.findNearestNpc(player, 2000)\nlocal nearestHostile = opengothic.worldutil.findNearestNpc(player, 2000, function(npc)\n    return npc:attitude() == opengothic.CONSTANTS.Attitude.ATT_HOSTILE\nend)\n</code></pre>"},{"location":"api-reference/helpers/world/#opengothicworldutilfindnearestitemoriginnpc-range-predicate","title":"<code>opengothic.worldutil.findNearestItem(originNpc, range, [predicate])</code>","text":"<p>Finds the nearest item around <code>originNpc</code>, with optional filtering.</p> <ul> <li><code>originNpc</code> (Npc): Origin NPC.</li> <li><code>range</code> (number): Search radius in world units.</li> <li><code>predicate</code> (function, optional): Filter callback <code>predicate(item) -&gt; boolean</code>.</li> <li>Returns: <code>Item</code> or <code>nil</code>.</li> </ul> <p>Behavior: - Without <code>predicate</code>, it uses the primitive <code>world:findNearestItem(...)</code>. - With <code>predicate</code>, it scans <code>world:detectItemsNear(...)</code> and returns the nearest passing item.</p> <pre><code>local player = opengothic.player()\n\nlocal nearestAny = opengothic.worldutil.findNearestItem(player, 2000)\nlocal nearestGold = opengothic.worldutil.findNearestItem(player, 2000, function(item)\n    return item:isGold()\nend)\n</code></pre>"},{"location":"concepts/architecture/","title":"Core Concept: API Architecture","text":"<p>This document explains the design philosophy behind the OpenGothic Lua scripting API. Understanding this architecture will help you choose the right tools for your mods and write more effective code.</p>"},{"location":"concepts/architecture/#the-three-layer-api","title":"The Three-Layer API","text":"<p>The scripting API is organized into three distinct layers, each serving a different purpose:</p> <pre><code>flowchart TB\n    subgraph convenience[\"Lua Convenience\"]\n        conv[\"quest.create() \u00b7 dialog.onOption() \u00b7 timer.every()\"]\n    end\n    subgraph daedalus[\"Daedalus Bridge\"]\n        daed[\"daedalus.get/set/call() \u00b7 vm.callWithContext()\"]\n    end\n    subgraph primitives[\"Primitives (C++ Engine)\"]\n        prim[\"npc:attribute() \u00b7 npc:takeAllFrom() \u00b7 world:isTime()\"]\n    end\n    convenience --&gt; primitives\n    daedalus --&gt; primitives\n    convenience -.-&gt; daedalus</code></pre>"},{"location":"concepts/architecture/#primitives","title":"Primitives","text":"<p>Primitives are the foundational building blocks of the API. They are implemented in C++ and exposed directly to Lua as methods on game objects (userdata).</p> <p>Characteristics: - Direct access to engine functionality - Minimal abstraction - they do exactly one thing - Often require numeric IDs rather than string names - Always available, even without <code>bootstrap.lua</code> - Includes <code>opengothic.daedalus.*</code> and <code>opengothic.vm.*</code> for Daedalus interop</p> <p>Examples: <pre><code>-- Primitives work with raw IDs and direct values\nlocal hp = npc:attribute(opengothic.CONSTANTS.Attribute.ATR_HITPOINTS)\nnpc:changeAttribute(opengothic.CONSTANTS.Attribute.ATR_HITPOINTS, -10, true)\n\nlocal instanceId = npc:instanceId()  -- Returns a number\ninventory:transfer(srcInventory, itemId, count, world)\ninventory:addItem(itemId, count)\n\n-- Daedalus bridge primitives (require loaded world)\nopengothic.daedalus.call(\"B_GivePlayerXP\", 100)\nlocal chapter = opengothic.daedalus.get(\"PLAYER_CHAPTER\")\n</code></pre></p> <p>When to use primitives: - When you need precise control over game mechanics - When building your own abstractions - When performance is critical (fewer function calls) - When the convenience methods don't fit your use case</p>"},{"location":"concepts/architecture/#daedalus-bridge","title":"Daedalus Bridge","text":"<p>Daedalus Bridge exposes raw VM interop APIs (<code>opengothic.daedalus.*</code>, <code>opengothic.vm.*</code>) for symbol access and explicit Daedalus calls.</p> <p>Characteristics: - Direct symbol/function access into Daedalus VM - Require a loaded world for mutating/call operations - Useful for migration and low-level introspection - External-function passthrough is currently unavailable (requires external-call bridge extension)</p> <p>Examples: <pre><code>-- Daedalus bridge primitives\nlocal chapter = opengothic.daedalus.get(\"PLAYER_CHAPTER\")\nlocal ok, _, err = opengothic.daedalus.tryCall(\"B_GivePlayerXP\", 100)\n</code></pre></p> <p>When to use Daedalus Bridge: - When no convenience wrapper exists yet - When migrating existing Daedalus logic incrementally - For symbol-level introspection/debugging</p> <p>Lifecycle considerations: - These methods only work after a world is loaded - Calling them during script load time will throw an error - Register event handlers at load time, but call Daedalus methods inside the handlers</p>"},{"location":"concepts/architecture/#lua-convenience","title":"Lua Convenience","text":"<p>Lua convenience methods are Lua functions defined in <code>bootstrap.lua</code> that compose primitives and safe wrappers into higher-level APIs.</p> <p>Characteristics: - Prefer engine primitives and safe wrappers - Some methods call dedicated engine hooks for common workflows - Higher-level inputs and standardized result/error shapes - Combine multiple primitives into one convenient call</p> <p>Examples: <pre><code>-- Lua convenience methods combine primitives and safe wrappers\nopengothic.quest.create(\"MY_QUEST\")\nlocal moved, err = opengothic.inventory.transferAll(player, chest:inventory())\nlocal nearest = opengothic.worldutil.findNearestNpc(player, 3000)\nlocal dmg = opengothic.DamageCalculator.calculate(attacker, victim, isSpell, spellId)  -- Uses primitives + bit32\n</code></pre></p> <p>When to use Lua convenience methods: - When you want predictable behavior without Daedalus side effects - For custom game mechanics that don't need original game logic - When building reusable utilities</p>"},{"location":"concepts/architecture/#choosing-between-layers","title":"Choosing Between Layers","text":"Scenario Recommendation Layer Give player an item <code>npc:giveItem()</code> Lua Convenience Custom damage calculation <code>npc:changeAttribute()</code> Primitive Check if player has a key <code>npc:hasItem()</code> Lua Convenience Transfer specific items with conditions <code>inventory:transfer()</code> Primitive Get current time <code>world:time()</code> Primitive Check if NPC is a specific type <code>npc:isInstance()</code> Lua Convenience Check if time is in a range <code>world:isTime()</code> Primitive Loot all items from a container <code>npc:takeAllFrom()</code> Primitive Register option-filter rules <code>dialog.onOption()</code> / <code>dialog.setOptionTimeWindow()</code> Lua Convenience Create a quest entry <code>opengothic.quest.create()</code> Lua Convenience Calculate damage with spell support <code>DamageCalculator.calculate()</code> Lua Convenience"},{"location":"concepts/architecture/#the-event-system","title":"The Event System","text":"<p>The event system allows your scripts to react to game events. Understanding how it works internally helps you write effective handlers.</p>"},{"location":"concepts/architecture/#registration-order-matters","title":"Registration Order Matters","text":"<p>When you call <code>opengothic.events.register()</code>, your handler is added to an ordered list and you get a handler ID back. When an event fires, handlers are called in the order they were registered:</p> <pre><code>-- Handler A is registered first\nlocal idA = opengothic.events.register(\"onNpcTakeDamage\", handlerA)\n\n-- Handler B is registered second\nlocal idB = opengothic.events.register(\"onNpcTakeDamage\", handlerB)\n\n-- When onNpcTakeDamage fires:\n-- 1. handlerA() is called first\n-- 2. If handlerA returns false/nil, handlerB() is called\n-- 3. If handlerA returns true, handlerB is NEVER called\n\n-- Later, you can remove a specific handler by ID:\nopengothic.events.unregister(\"onNpcTakeDamage\", idB)\n</code></pre>"},{"location":"concepts/architecture/#blocking-vs-observing","title":"Blocking vs. Observing","text":"<p>Events fall into two categories based on how they use return values:</p> <p>Blocking Events (Interception Hooks)</p> <p>These events fire before the default game logic. Your handler can prevent the default behavior by returning <code>true</code>.</p> <pre><code>opengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, isSpell, spellId)\n    if victim:isPlayer() then\n        return true  -- Block ALL damage to player (god mode)\n    end\n    return false  -- Let damage proceed normally\nend)\n</code></pre> <p>Common blocking events: <code>onNpcTakeDamage</code>, <code>onOpen</code>, <code>onRansack</code>, <code>onItemPickup</code></p> <p>Notification Events</p> <p>These events fire after something has happened. The engine ignores their final handled state, but returning <code>true</code> still stops later Lua handlers in the same dispatch chain.</p> <pre><code>opengothic.events.register(\"onNpcSpawn\", function(npc)\n    print(npc:displayName() .. \" spawned\")\n    return false -- keep the chain open for other mods\nend)\n</code></pre> <p>Common notification events: <code>onNpcSpawn</code>, <code>onNpcRemove</code>, <code>onWorldLoaded</code>, <code>onSessionExit</code>, <code>onUpdate</code>, <code>onGameMinuteChanged</code></p>"},{"location":"concepts/architecture/#first-handler-wins","title":"First Handler Wins","text":"<p>For blocking events, the first handler to return <code>true</code> stops the chain. This has important implications:</p> <pre><code>-- Mod A: Makes the player invincible\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, ...)\n    if victim:isPlayer() then\n        return true  -- Blocks damage, stops chain\n    end\n    return false\nend)\n\n-- Mod B: Logs all damage (registered after Mod A)\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, ...)\n    print(victim:displayName() .. \" took damage from \" .. attacker:displayName())\n    return false\nend)\n\n-- Result: Mod B's logging NEVER runs for player damage\n-- because Mod A's handler returns true first\n</code></pre> <p>Tip: If you only want to observe an event (logging, analytics), always return <code>false</code> to let other handlers run.</p>"},{"location":"concepts/architecture/#script-loading","title":"Script Loading","text":"<p>Understanding when and how scripts load helps you write reliable mods.</p>"},{"location":"concepts/architecture/#load-order","title":"Load Order","text":"<ol> <li>Application Start: The Lua VM is created</li> <li>Bootstrap: <code>bootstrap.lua</code> runs, setting up the API</li> <li>Script Discovery: Engine scans <code>Data/opengothic/scripts/</code> recursively</li> <li>Script Execution: Each <code>.lua</code> file is executed in discovery order</li> </ol> <p>Important: Discovery order depends on the filesystem and is not guaranteed to be consistent across different systems or runs. Do not rely on your script loading before another mod's script.</p>"},{"location":"concepts/architecture/#script-load-time-vs-event-time","title":"Script Load Time vs. Event Time","text":"<p>Code at the top level of your script runs at load time (before any game session):</p> <pre><code>-- This runs immediately when the script loads (at application start)\nlocal MY_ITEM_ID = opengothic.resolve(\"ITMI_GOLD\")  -- May be nil before a world is loaded\nprint(\"My mod loaded!\")\n\n-- This ALSO runs at load time - it registers the handler\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, ...)\n    -- But this code inside runs at EVENT TIME (during gameplay)\n    local player = opengothic.player()  -- Safe: world exists when event fires\nend)\n</code></pre> <p>What's safe at load time: - <code>opengothic.events.register()</code> - Always works - Defining functions and variables</p> <p>What requires a world (event time only): - <code>opengothic.resolve()</code> - Returns <code>nil</code> if no world - <code>opengothic.player()</code> - Returns nil if no world - <code>opengothic.world()</code> - Returns nil if no world - <code>opengothic.daedalus.set()</code> - Throws error if no world - <code>opengothic.daedalus.call()</code> - Throws error if no world</p> <p>See VM Lifecycles for more details.</p>"},{"location":"concepts/architecture/#design-rationale","title":"Design Rationale","text":""},{"location":"concepts/architecture/#why-three-layers","title":"Why Three Layers?","text":"<p>Primitives exist because: - They provide maximum flexibility for advanced modders - They're the foundation that everything else builds on - Some tasks require direct engine access - They have minimal overhead</p> <p>Daedalus Bridge exists because: - Gothic has extensive existing game logic in Daedalus - Mods often need symbol-level interop during migration - VM context calls and external registration are needed integration points</p> <p>Lua Convenience exists because: - Some helpers don't need Daedalus at all - Combining primitives into reusable patterns reduces boilerplate - These methods can work in more contexts (no world required for some)</p>"},{"location":"concepts/architecture/#why-first-handler-wins","title":"Why First-Handler-Wins?","text":"<p>The event system uses first-handler-wins because: - It's simple and predictable - It allows mods to fully \"take over\" game mechanics - It matches how interception typically works (firewalls, middleware) - It avoids complex priority systems that are hard to debug</p> <p>The tradeoff is that mod compatibility requires coordination. If two mods both want to handle the same event, they need to be aware of each other or use notification-style handlers that don't block.</p>"},{"location":"concepts/architecture/#summary","title":"Summary","text":"Concept Key Point Primitives Direct C++ methods, use numeric IDs, maximum control Daedalus Bridge Raw VM interop APIs (<code>daedalus.*</code>, <code>vm.*</code>); external calls currently unsupported Lua Convenience Lua helpers composed from primitives and safe wrappers Event Registration Handlers called in registration order Blocking Events Return <code>true</code> to stop default behavior and other handlers Notification Events Return value ignored, just for observation Script Loading Load order is filesystem-dependent, not guaranteed"},{"location":"concepts/events-and-hooks/","title":"Core Concept: Events and Hooks","text":"<p>The event system is the heart of the scripting engine. It is the primary mechanism through which your mods can react to and modify game behavior.</p> <p>For a deeper understanding of how events work internally (registration order, blocking mechanics), see the Architecture documentation.</p>"},{"location":"concepts/events-and-hooks/#what-are-events","title":"What are Events?","text":"<p>As the game runs, the engine \"fires\" events at key moments. These are also often called \"hooks\". For example:</p> <ul> <li>An NPC is about to take damage (<code>onNpcTakeDamage</code>)</li> <li>The player opens a container (<code>onOpen</code>)</li> <li>A spell is cast (<code>onSpellCast</code>)</li> <li>A new game session begins (<code>onLoadGame</code>)</li> </ul> <p>Your scripts can \"listen\" for these events and execute code when they happen.</p>"},{"location":"concepts/events-and-hooks/#registering-an-event-handler","title":"Registering an Event Handler","text":"<p>To listen for an event, you need to register a handler function. A handler is simply a Lua function that the engine will call when the event occurs. You do this using <code>opengothic.events.register</code>.</p> <p><code>opengothic.events.register(eventName, handlerFunction) -&gt; handlerId|nil</code></p> <ul> <li><code>eventName</code> (string): The name of the event you want to listen for. A full list is available in the Events Reference.</li> <li><code>handlerFunction</code> (function): The function to be called when the event fires.</li> <li>Return value: A numeric <code>handlerId</code> on success, or <code>nil</code> on invalid arguments.</li> </ul> <pre><code>-- Define a function\nlocal function myHandler(some, arguments)\n    -- Your code here\nend\n\n-- Register it to an event\nlocal handlerId = opengothic.events.register(\"onSomeEvent\", myHandler)\n</code></pre>"},{"location":"concepts/events-and-hooks/#unregistering-a-handler","title":"Unregistering a Handler","text":"<p>Use <code>opengothic.events.unregister(eventName, handlerId)</code> when you no longer need a handler.</p> <pre><code>local handlerId = opengothic.events.register(\"onUpdate\", function(dt)\n    print(\"Tick: \" .. tostring(dt))\n    return false\nend)\n\n-- Later:\nopengothic.events.unregister(\"onUpdate\", handlerId)\n</code></pre>"},{"location":"concepts/events-and-hooks/#handler-arguments","title":"Handler Arguments","text":"<p>Each event provides a specific set of arguments to its handler function. For example, <code>onNpcTakeDamage</code> provides the <code>victim</code>, <code>attacker</code>, <code>isSpell</code>, and <code>spellId</code>.</p> <p><pre><code>local function onDamage(victim, attacker, isSpell, spellId)\n    local message = victim:displayName() .. \" was hit by \" .. attacker:displayName()\n    opengothic.printMessage(message)\n    return false\nend\n\nopengothic.events.register(\"onNpcTakeDamage\", onDamage)\n</code></pre> You must check the API Reference to know the exact arguments for each event.</p>"},{"location":"concepts/events-and-hooks/#controlling-game-logic-with-return-values","title":"Controlling Game Logic with Return Values","text":"<p>Many event hooks allow you to change the game's behavior based on what your handler function returns.</p> <p>There are two main types of hooks:</p>"},{"location":"concepts/events-and-hooks/#1-interception-hooks","title":"1. Interception Hooks","text":"<p>These hooks fire before the default game logic runs. They allow you to completely override or prevent that logic.</p> <ul> <li>Return <code>false</code> or <code>nil</code>: The default game logic will proceed as normal. This is the most common return value.</li> <li>Return <code>true</code>: The default game logic is stopped. The game assumes your script has handled the event completely.</li> </ul> <p>Example: Creating an invincible NPC</p> <p>This script listens for <code>onNpcTakeDamage</code>. If the victim is the NPC named \"BOB\", the handler returns <code>true</code>. This tells the game engine \"stop processing this damage event,\" effectively making Bob immune to all damage. For any other NPC, it returns <code>false</code>, and they take damage as usual.</p> <pre><code>-- Resolve the Daedalus symbol for PC_BOB once at script load time\n-- opengothic.resolve() returns a numeric symbol index, or nil if not found\nlocal PC_BOB_ID = opengothic.resolve(\"PC_BOB\")\n\nlocal function makeBobInvincible(victim, attacker, isSpell, spellId)\n    -- Compare the victim's instance ID to the resolved symbol index\n    -- (Note: This assumes you created an NPC with instance name PC_BOB)\n    if PC_BOB_ID and victim:instanceId() == PC_BOB_ID then\n        opengothic.printMessage(\"Bob is invincible!\")\n        return true -- Block the damage\n    end\n\n    -- For everyone else, let the damage happen\n    return false\nend\n\nopengothic.events.register(\"onNpcTakeDamage\", makeBobInvincible)\n</code></pre>"},{"location":"concepts/events-and-hooks/#2-notification-hooks","title":"2. Notification Hooks","text":"<p>These hooks are for observation only. They fire after something has already happened.</p> <p>The engine ignores the final \"handled\" state for these events, but Lua callback chaining still stops when a handler returns <code>true</code>. In practice, observation handlers should return <code>false</code>/<code>nil</code> unless they intentionally want to stop later Lua handlers.</p> <p>Examples include: - <code>onNpcSpawn</code>: Fires after an NPC has been spawned into the world. - <code>onSessionExit</code>: Fires when the player is returning to the main menu.</p> <p>Recommendation: return <code>false</code> from notification handlers to keep them composable with other mods.</p>"},{"location":"concepts/lifecycles/","title":"Core Concept: VM Lifecycles","text":"<p>A \"Virtual Machine\" (VM) is the environment where scripts are executed. OpenGothic uses two different VMs that run in parallel: the Lua VM for mods, and the Daedalus VM for the original game's scripts. Understanding their lifecycles is critical for writing stable, bug-free mods.</p>"},{"location":"concepts/lifecycles/#the-lua-vm-scriptengine","title":"The Lua VM (<code>ScriptEngine</code>)","text":"<p>The Lua VM is where all your <code>.lua</code> mod scripts live and run.</p> <ul> <li>Created: The Lua VM is created once when the OpenGothic application first launches, even before you see the main menu.</li> <li>Persists: It stays alive for the entire duration of the application. It persists across new games, loaded games, and trips back to the main menu.</li> <li>Destroyed: The Lua VM is only destroyed when you quit the OpenGothic application entirely.</li> </ul>"},{"location":"concepts/lifecycles/#implications-for-modders","title":"Implications for Modders","text":"<ul> <li> <p>Global state is persistent. If you define a global variable in your Lua script, its value will persist until the game is closed. This can be powerful, but also dangerous if you're not careful.</p> </li> <li> <p>Lifecycle hooks are reliable. Because the VM is always running, you can reliably use hooks like <code>onStartGame</code> or <code>onLoadGame</code> to initialize or reset your mod's state for a new session.</p> </li> <li> <p>Event registrations are persistent too. A handler registered at script load stays registered across sessions until you explicitly unregister it.</p> </li> </ul> <pre><code>local sessionCounter = 0\n\n-- This function will be called every time a save is loaded\nlocal function onGameLoaded(savegameName)\n    sessionCounter = sessionCounter + 1\n    opengothic.printMessage(\"This is session number \" .. sessionCounter)\nend\n\n-- This registration only happens once when the script is first loaded\nopengothic.events.register(\"onLoadGame\", onGameLoaded)\n</code></pre> <p>In the example above, the <code>sessionCounter</code> will correctly increment every time you load a game, because it's a global variable in the persistent Lua VM.</p> <p><code>onUpdate</code> and <code>onGameMinuteChanged</code> are only fired while a game session is active. They do not run on the main menu.</p>"},{"location":"concepts/lifecycles/#the-daedalus-vm-gamescript","title":"The Daedalus VM (<code>GameScript</code>)","text":"<p>The Daedalus VM runs the original game's compiled <code>.dat</code> scripts. The Lua scripting engine provides a bridge to interact with it.</p> <ul> <li>Created: A new Daedalus VM is created every time a game session begins. This happens when you start a new game or load a save file.</li> <li>Persists: It only stays alive for the current game session.</li> <li>Destroyed: The Daedalus VM is destroyed whenever the session ends (e.g., loading another save, or returning to the main menu).</li> </ul>"},{"location":"concepts/lifecycles/#implications-for-modders_1","title":"Implications for Modders","text":"<ul> <li> <p>Daedalus state is NOT persistent. Any changes you make to Daedalus global variables will be lost when the session ends. You cannot use Daedalus globals to store information across saves (that's what save files are for).</p> </li> <li> <p><code>opengothic.daedalus.*</code> only works in-game. You can only use the Daedalus bridge functions when a world is loaded. When called from the main menu (before any world is loaded):</p> <ul> <li><code>daedalus.get()</code> returns <code>nil</code> gracefully (safe to call)</li> <li><code>daedalus.set()</code>, <code>daedalus.call()</code>, and <code>vm.registerExternal()</code> will throw a Lua error</li> </ul> </li> <li> <p>Lua externals must be re-registered. If you use <code>opengothic.vm.registerExternal</code> to create a Lua callback for Daedalus, the engine automatically handles re-registering it every time a new Daedalus VM is created. You do not need to worry about this, but it's good to know why it's necessary.</p> </li> </ul>"},{"location":"concepts/lifecycles/#persisting-data-across-sessions","title":"Persisting Data Across Sessions","text":"<p>While Lua globals persist during the application lifetime, they are lost when the game closes. For data that must survive across game restarts, use <code>opengothic.storage</code>:</p> Storage Type Lifetime Survives Restart? Use Case Lua globals Application No Session counters, caches <code>opengothic.storage</code> Save file Yes Quest progress, mod state Daedalus globals Session No Temporary game flags <p>See the Storage API for usage details and best practices.</p> <p>At the start of each new game/load session, the engine clears <code>opengothic.storage</code> before optionally applying data from <code>game/lua</code>. This prevents stale values from leaking between sessions.</p>"},{"location":"concepts/lifecycles/#summary","title":"Summary","text":"Feature Lua VM Daedalus VM Creation On application start On new game / load game Persistence Entire application lifetime Single game session Destruction On application exit On session end (exit to menu) State Globals persist across saves Globals are reset each session Modding Implication Good for persistent mod logic Good for temporary game state"},{"location":"daedalus-bridge/","title":"Daedalus Bridge Overview","text":"<p>This section is targeted at modders already fluent in Daedalus/Ikarus/LeGo workflows.</p> <p>The goal is not to hide Daedalus internals. The goal is to document exactly how OpenGothic bridges Lua &lt;-&gt; Daedalus, where behavior differs from legacy tools, and which high-level APIs you should prefer today.</p> <p>Use this together with:</p> <ul> <li>Core Concept: API Architecture</li> <li>Core Concept: VM Lifecycles</li> </ul>"},{"location":"daedalus-bridge/#what-the-bridge-is","title":"What the Bridge Is","text":"<p>OpenGothic exposes two bridge layers:</p> <ul> <li><code>opengothic.daedalus.*</code>:</li> <li>Direct symbol/function access (<code>get</code>, <code>set</code>, <code>call</code>).</li> <li><code>opengothic.vm.*</code>:</li> <li>Advanced VM interop (<code>callWithContext</code>, <code>registerExternal</code>, <code>getSymbol</code>, <code>enumerate</code>).</li> </ul> <p>Additionally, non-throwing bridge ergonomics wrappers are available for migration-safe usage:</p> <ul> <li><code>opengothic.daedalus.tryCall</code>, <code>trySet</code>, <code>exists</code></li> <li><code>opengothic.vm.callContextSafe</code>, <code>callSelf</code>, <code>callSelfOther</code></li> </ul> <p>Both require an active game world for most operations (exception: <code>daedalus.get</code> returns <code>nil</code> when no world is loaded).</p>"},{"location":"daedalus-bridge/#what-to-prefer-first","title":"What to Prefer First","text":"<p>Experienced Daedalus users should still prefer existing convenience APIs when they already model the use case:</p> <ul> <li>Quests: <code>opengothic.quest.*</code></li> <li>Dialog rules: <code>opengothic.dialog.*</code></li> <li>AI actions: <code>opengothic.ai.*</code></li> <li>Timers: <code>opengothic.timer.*</code></li> <li>Inventory/world helpers: <code>opengothic.inventory.*</code>, <code>opengothic.worldutil.*</code></li> <li>World/NPC wrappers: <code>Npc:giveItem</code>, <code>Npc:hasItem</code>, <code>World:insertNpc</code>, <code>World:insertItem</code></li> </ul> <p>Quest note: <code>opengothic.quest.*</code> uses dedicated engine quest hooks (<code>_quest*</code>).</p> <p>Direct bridge calls are best when:</p> <ol> <li>You need an unwrapped Daedalus function now.</li> <li>You are porting existing Daedalus logic incrementally.</li> <li>You need symbol-level introspection/debugging.</li> </ol> <p>Current limitation:</p> <ul> <li>External-function passthrough is unavailable in the bridge (<code>daedalus.call</code> / <code>vm.callWithContext</code>).</li> <li>Use convenience wrappers/primitives for affected functionality until external-call bridge extension is available.</li> </ul>"},{"location":"daedalus-bridge/#documentation-map","title":"Documentation Map","text":"<ol> <li>Contracts: exact argument, return, and error behavior.</li> <li>Internals: marshalling rules, context handling, lifecycle details.</li> <li>Migration Map: Daedalus calls mapped to existing OpenGothic APIs.</li> <li>Recipes: practical patterns for mixed Lua/Daedalus mods.</li> <li>Troubleshooting: common runtime failures and fixes.</li> </ol>"},{"location":"daedalus-bridge/#community-context","title":"Community Context","text":"<p>The bridge documentation assumes common Gothic modding patterns seen across DE/PL/RU communities:</p> <ul> <li>Base Daedalus is often extended with Ikarus/LeGo/Union or zParserExtender-style tooling.</li> <li>Advanced modders value low-level control, but stability and compatibility are recurring pain points.</li> <li>The practical migration path is usually:</li> <li>keep critical Daedalus behavior,</li> <li>bridge safely from Lua,</li> <li>replace with higher-level OpenGothic helpers where behavior matches.</li> </ul> <p>Reference reading:</p> <ul> <li>Gothic Modding Community Extenders: https://gothic-modding-community.github.io/gmc/extenders/</li> <li>GMC Ikarus page: https://gothic-modding-community.github.io/gmc/extenders/ikarus/</li> <li>GMC LeGo page: https://gothic-modding-community.github.io/gmc/extenders/lego/</li> <li>Polish scripts docs (GMC): https://gothic-modding-community.github.io/gmc/pl/zengin/scripts/</li> <li>World of Gothic wiki (DE): https://wiki.worldofgothic.de/doku.php?id=editing:skripte</li> <li>zParserExtender background (RU, World of Players): https://worldofplayers.ru/threads/41999/</li> </ul>"},{"location":"daedalus-bridge/contracts/","title":"Daedalus Bridge Contracts","text":"<p>This page documents current bridge behavior exactly as implemented.</p> <p>If you are porting old Daedalus/Ikarus/LeGo code, treat this as the source of truth for return values, error behavior, and edge cases.</p>"},{"location":"daedalus-bridge/contracts/#error-model","title":"Error Model","text":"<ul> <li>Bridge functions that call <code>luaL_error(...)</code> raise a Lua error.</li> <li>Use <code>pcall(...)</code> if you want non-fatal behavior in scripts.</li> <li>Bridge functions that return <code>nil</code>/<code>false</code> do so intentionally and do not raise.</li> <li>Calls to external function symbols currently raise an explicit unsupported-bridge error.</li> </ul>"},{"location":"daedalus-bridge/contracts/#opengothicdaedalus","title":"<code>opengothic.daedalus.*</code>","text":"Function World required Return Failure behavior Notes <code>daedalus.get(name, index?)</code> No symbol value or <code>nil</code> returns <code>nil</code> <code>nil</code> for no world, unknown symbol, or out-of-bounds index <code>daedalus.set(name, value, index?)</code> Yes no return raises Lua error only <code>int</code>, <code>float</code>, <code>string</code> symbols are writable <code>daedalus.call(funcName, ...)</code> Yes function return (<code>int</code>/<code>float</code>/<code>string</code>) or no return raises Lua error external function symbols are currently unsupported <code>daedalus.tryCall(funcName, ...)</code> Yes <code>ok, result, err</code> returns <code>ok=false</code> + <code>err</code> string non-throwing wrapper around <code>daedalus.call</code> <code>daedalus.trySet(name, value, index?)</code> Yes <code>ok, err</code> returns <code>ok=false</code> + <code>err</code> string non-throwing wrapper around <code>daedalus.set</code> <code>daedalus.exists(name)</code> No <code>boolean</code> returns <code>false</code> checks symbol existence through <code>vm.getSymbol</code>"},{"location":"daedalus-bridge/contracts/#daedalusget-value-mapping","title":"<code>daedalus.get</code> value mapping","text":"<p><code>daedalus.get</code> maps Daedalus symbols to Lua values as follows:</p> Daedalus symbol type Lua value <code>INT</code> <code>number</code> (integer) <code>FLOAT</code> <code>number</code> <code>STRING</code> <code>string</code> <code>INSTANCE</code> (<code>C_NPC</code>) <code>Npc</code> userdata (if resolvable in world), else <code>nil</code> <code>INSTANCE</code> (<code>C_ITEM</code>) <code>Item</code> userdata (if resolvable in world), else <code>nil</code> <code>INSTANCE</code> (other class) symbol index as <code>number</code> <code>FUNCTION</code> <code>number</code> (symbol int value) unsupported/unknown <code>nil</code>"},{"location":"daedalus-bridge/contracts/#daedaluscall-argument-mapping","title":"<code>daedalus.call</code> argument mapping","text":"Lua argument Daedalus stack push integer-like <code>number</code> <code>int</code> non-integer <code>number</code> <code>float</code> <code>string</code> <code>string</code> <code>Npc</code> userdata instance pointer <code>Item</code> userdata instance pointer <code>nil</code> <code>0</code> other userdata <code>0</code> <code>table</code>/<code>boolean</code>/<code>function</code>/thread raises <code>unsupported argument type</code> <p>Arguments are pushed in reverse Lua order before the VM call.</p>"},{"location":"daedalus-bridge/contracts/#daedalustrycall-daedalustryset-contracts","title":"<code>daedalus.tryCall</code> / <code>daedalus.trySet</code> contracts","text":"<ul> <li>These wrappers convert thrown bridge errors into return values.</li> <li>They do not raise on normal invalid usage.</li> <li><code>tryCall</code> return shape:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, \"error_text\"</code></li> <li><code>trySet</code> return shape:</li> <li>success: <code>true, nil</code></li> <li>failure: <code>false, \"error_text\"</code></li> <li><code>trySet</code> validates:</li> <li>non-empty symbol name</li> <li>numeric <code>index</code> when provided</li> </ul>"},{"location":"daedalus-bridge/contracts/#opengothicvm","title":"<code>opengothic.vm.*</code>","text":"Function World required Return Failure behavior Notes <code>vm.callWithContext(funcName, context, ...)</code> Yes function return (<code>int</code>/<code>float</code>/<code>string</code>) or no return raises Lua error context table required at arg 2; external symbols are currently unsupported <code>vm.callContextSafe(funcName, context, ...)</code> Yes <code>ok, result, err</code> returns <code>ok=false</code> + <code>err</code> string non-throwing wrapper around <code>vm.callWithContext</code> <code>vm.callSelf(funcName, selfNpc, ...)</code> Yes <code>ok, result, err</code> returns <code>ok=false</code> + <code>err</code> string shorthand for <code>{ self = npc }</code> context <code>vm.callSelfOther(funcName, selfNpc, otherNpc, ...)</code> Yes <code>ok, result, err</code> returns <code>ok=false</code> + <code>err</code> string shorthand for <code>{ self = npc, other = npc }</code> context <code>vm.registerExternal(name, luaFn)</code> Yes no return raises Lua error callback currently called with no args, integer return consumed <code>vm.getSymbol(name)</code> No symbol table or <code>nil</code> returns <code>nil</code> <code>nil</code> for no world or unknown symbol <code>vm.enumerate(className, callback)</code> No no return does not throw on callback errors callback errors are logged and iteration stops"},{"location":"daedalus-bridge/contracts/#vmcallwithcontext-context-handling","title":"<code>vm.callWithContext</code> context handling","text":"<ul> <li>Recognized keys: <code>self</code>, <code>other</code>, <code>victim</code>, <code>item</code>.</li> <li><code>self</code>/<code>other</code>/<code>victim</code> expect <code>Npc</code> userdata.</li> <li><code>item</code> expects <code>Item</code> userdata.</li> <li>Invalid or missing keys are ignored.</li> <li>Previous VM context is restored after the call and also restored on exceptions.</li> </ul>"},{"location":"daedalus-bridge/contracts/#vmcallwithcontext-argument-mapping","title":"<code>vm.callWithContext</code> argument mapping","text":"Lua argument Daedalus stack push integer-like <code>number</code> <code>int</code> non-integer <code>number</code> <code>float</code> <code>string</code> <code>string</code> <code>Npc</code> userdata instance pointer <code>Item</code> userdata instance pointer any unsupported type (including <code>nil</code>) <code>0</code> <p>Unlike <code>daedalus.call</code>, unsupported non-userdata types are coerced to <code>0</code> instead of raising.</p>"},{"location":"daedalus-bridge/contracts/#vmcallcontextsafe-vmcallself-contracts","title":"<code>vm.callContextSafe</code> / <code>vm.callSelf*</code> contracts","text":"<ul> <li><code>vm.callContextSafe</code> validates:</li> <li>non-empty function name</li> <li>context must be a table</li> <li><code>vm.callSelf</code> and <code>vm.callSelfOther</code> validate NPC userdata inputs before call.</li> <li>Return shape for all three wrappers:</li> <li>success: <code>true, result, nil</code></li> <li>failure: <code>false, nil, \"error_text\"</code></li> </ul>"},{"location":"daedalus-bridge/contracts/#vmgetsymbol-return-schema","title":"<code>vm.getSymbol</code> return schema","text":"<p>On success:</p> <pre><code>{\n  name = \"SYMBOL_NAME\",\n  index = 123,\n  count = 1,\n  isConst = true,\n  type = \"int\" | \"float\" | \"string\" | \"class\" | \"function\" | \"prototype\" | \"instance\" | \"void\",\n  value = ... -- only for scalar int/float/string symbols\n}\n</code></pre>"},{"location":"daedalus-bridge/contracts/#vmenumerate-callback-schema","title":"<code>vm.enumerate</code> callback schema","text":"<p>For each visited symbol, callback receives:</p> <pre><code>{\n  name = \"SYMBOL_NAME\",\n  index = 123\n}\n</code></pre> <ul> <li>Return <code>false</code> from callback to stop enumeration.</li> <li>Any other return value continues enumeration.</li> </ul>"},{"location":"daedalus-bridge/contracts/#lifecycle-contracts","title":"Lifecycle Contracts","text":"<ul> <li>Daedalus VM is session-scoped. It is recreated on new game/load.</li> <li>Lua externals registered via <code>vm.registerExternal(...)</code> are automatically re-registered when the world is loaded again.</li> <li>Do not use Daedalus globals for persistence across game restarts. Use <code>opengothic.storage</code> for save-bound state.</li> </ul> <p>See VM Lifecycles for lifecycle background.</p>"},{"location":"daedalus-bridge/internals/","title":"Daedalus Bridge Internals","text":"<p>This page explains how the bridge works internally so experienced Daedalus modders can reason about behavior and failure modes.</p>"},{"location":"daedalus-bridge/internals/#execution-flow","title":"Execution Flow","text":"<p>Bridge calls follow this pattern:</p> <ol> <li>Validate Lua-side arguments.</li> <li>Acquire active world and Daedalus VM.</li> <li>Resolve target symbol/function.</li> <li>Marshal Lua arguments onto Daedalus VM stack.</li> <li>Execute VM call.</li> <li>Marshal return value back to Lua.</li> </ol> <p>The two direct call paths are:</p> <ul> <li><code>opengothic.daedalus.call(...)</code></li> <li><code>opengothic.vm.callWithContext(...)</code></li> </ul> <p>Some convenience APIs (notably <code>opengothic.quest.*</code>) use dedicated engine hooks.</p> <p>External passthrough status:</p> <ul> <li>Function symbols marked as external are currently rejected by both call paths.</li> <li>This requires an external-call bridge extension before raw external calls can be supported.</li> </ul>"},{"location":"daedalus-bridge/internals/#argument-marshalling-details","title":"Argument Marshalling Details","text":""},{"location":"daedalus-bridge/internals/#daedaluscall","title":"<code>daedalus.call</code>","text":"<ul> <li>Supports <code>number</code>, <code>string</code>, <code>Npc</code> userdata, <code>Item</code> userdata, and <code>nil</code>.</li> <li><code>nil</code> is marshalled as integer <code>0</code>.</li> <li>Unknown userdata is marshalled as <code>0</code>.</li> <li><code>table</code>, <code>boolean</code>, and <code>function</code> arguments are rejected with a Lua error.</li> <li>Arguments are pushed in reverse order before the VM call.</li> </ul>"},{"location":"daedalus-bridge/internals/#vmcallwithcontext","title":"<code>vm.callWithContext</code>","text":"<ul> <li>Same numeric/string/userdata conversions as above.</li> <li>Unsupported argument types are coerced to <code>0</code> instead of raising.</li> <li>This is intentionally permissive for mixed/legacy call sites.</li> </ul>"},{"location":"daedalus-bridge/internals/#context-pointer-handling","title":"Context Pointer Handling","text":"<p><code>vm.callWithContext</code> can set Daedalus global context pointers:</p> <ul> <li><code>SELF</code></li> <li><code>OTHER</code></li> <li><code>VICTIM</code></li> <li><code>ITEM</code></li> </ul> <p>via keys in the Lua context table:</p> <pre><code>opengothic.vm.callWithContext(\"ZS_Attack\", {\n    self = attackerNpc,\n    other = targetNpc\n})\n</code></pre> <p>Internal guarantees:</p> <ul> <li>Previous context pointers are captured before mutation.</li> <li>Pointers are restored after successful calls.</li> <li>Pointers are also restored when the VM call throws.</li> </ul> <p>This allows reentrant Lua logic without leaking call context into later script execution.</p>"},{"location":"daedalus-bridge/internals/#symbol-access-model","title":"Symbol Access Model","text":"<p><code>daedalus.get</code> resolves a symbol by name and reads by optional index.</p> <p>Important instance behavior:</p> <ul> <li><code>C_NPC</code> instance symbols resolve to live <code>Npc</code> userdata only if corresponding world object exists.</li> <li><code>C_ITEM</code> instance symbols resolve to live <code>Item</code> userdata only if corresponding world object exists.</li> <li>Other instance classes are returned as raw symbol index integers.</li> </ul> <p>This is why some instance lookups produce <code>nil</code> even for valid symbol names: symbol exists, but no live runtime object is currently mapped.</p>"},{"location":"daedalus-bridge/internals/#externals-lua-daedalus-lua","title":"Externals: Lua -&gt; Daedalus -&gt; Lua","text":"<p><code>vm.registerExternal(name, luaFn)</code> registers a Lua callback under a Daedalus external name.</p> <p>Current implementation details:</p> <ul> <li>Lua callback is invoked with no positional arguments.</li> <li>Callback return value is read as integer (non-number becomes <code>0</code>).</li> <li>Registered externals are retained in script engine state.</li> <li>On world/session load, externals are automatically re-registered in the new Daedalus VM.</li> </ul> <p>Practical implication:</p> <ul> <li>You can register once in script init and rely on session reload re-registration.</li> <li>Lua externals remain callable from Daedalus side.</li> <li>Raw Lua-&gt;Daedalus external passthrough is currently unavailable.</li> </ul>"},{"location":"daedalus-bridge/internals/#enumeration-and-introspection","title":"Enumeration and Introspection","text":"<p><code>vm.getSymbol(name)</code> gives focused symbol metadata.</p> <p><code>vm.enumerate(className, callback)</code> scans symbol table entries:</p> <ul> <li>Empty <code>className</code> enumerates all symbols.</li> <li>Non-empty <code>className</code> filters by exact parent class name.</li> <li>Callback errors are logged and stop iteration; they are not rethrown as Lua errors.</li> </ul>"},{"location":"daedalus-bridge/internals/#bridge-boundary","title":"Bridge Boundary","text":"<p>The bridge is intentionally conservative:</p> <ul> <li>No direct memory-address primitives.</li> <li>No pointer arithmetic APIs.</li> <li>No implicit persistence in Daedalus globals between sessions.</li> </ul> <p>If you need mod state persistence, use <code>opengothic.storage</code>.</p> <p>If you need high-level behaviors, prefer existing convenience wrappers first:</p> <ul> <li><code>opengothic.quest.*</code></li> <li><code>opengothic.dialog.*</code></li> <li><code>opengothic.ai.*</code></li> <li><code>opengothic.timer.*</code></li> <li><code>opengothic.inventory.*</code></li> </ul>"},{"location":"daedalus-bridge/migration-map/","title":"Daedalus Migration Map","text":"<p>This map is for incremental migration: keep behavior, reduce boilerplate, and prefer maintained wrappers where available.</p>"},{"location":"daedalus-bridge/migration-map/#daedalus-call-existing-opengothic-api","title":"Daedalus Call -&gt; Existing OpenGothic API","text":"Legacy Daedalus call Preferred OpenGothic API Notes <code>Log_CreateTopic(topic, section)</code> <code>opengothic.quest.create(topic, section)</code> Uses dedicated <code>_questCreateTopic</code> hook; section defaults to <code>MISSIONS</code> <code>Log_SetTopicStatus(topic, status)</code> <code>opengothic.quest.setState(topic, status)</code> Uses dedicated <code>_questSetTopicStatus</code> hook; accepts numeric or string status <code>Log_AddEntry(topic, text)</code> <code>opengothic.quest.addEntry(topic, text)</code> Uses dedicated <code>_questAddEntry</code> hook <code>Npc_KnowsInfo(player, infoId)</code> No direct helper Use explicit quest/dialog state in Lua for availability checks <code>CreateInvItems(npc, itemId, count)</code> <code>npc:giveItem(itemSymbol, count)</code> Uses item symbol names <code>Npc_RemoveInvItems(npc, itemId, count)</code> No direct helper Use inventory primitives (<code>transfer</code>, <code>transferAll</code>, <code>itemCount</code>) <code>Npc_HasItems(npc, itemId)</code> <code>npc:hasItem(itemSymbol, minCount)</code> Boolean helper <code>EquipItem(npc, itemId)</code> No direct helper Use exposed equipment-related primitives where available <code>Wld_InsertNpc(npcId, wp)</code> <code>world:insertNpc(npcSymbol, waypoint)</code> Returns inserted NPC if found <code>Wld_InsertItem(itemId, wp)</code> <code>world:insertItem(itemSymbol, waypoint)</code> Returns inserted Item if found <code>Snd_Play(name)</code> <code>opengothic.sound.play(name)</code> World-level sound helper <code>Snd_Play3D(npc, name)</code> No direct helper Pending external-call bridge extension <code>Wld_PlayEffect(name, src, dst, ...)</code> <code>opengothic.effect.play(name, src, dst)</code> Plays at source position <code>Wld_StopEffect(name)</code> No direct helper Pending effect-stop primitive/helper"},{"location":"daedalus-bridge/migration-map/#legacy-utility-pattern-current-convenience-api","title":"Legacy Utility Pattern -&gt; Current Convenience API","text":"Common legacy pattern Current OpenGothic helper Why prefer it Dialog option filtering chains <code>opengothic.dialog.onOption</code>, <code>blockOption</code>, <code>setOptionTimeWindow</code> Built-in validation and hook lifecycle handling Manual attack/flee command chains <code>opengothic.ai.attackTarget</code>, <code>flee</code>, <code>reset</code>, <code>isCombatReady</code> Safer error handling and clearer intent Hand-rolled update-loop timers <code>opengothic.timer.after</code>, <code>every</code>, <code>everyGameMinute</code>, <code>cancel</code> Deterministic scheduler wrapper with isolated callback errors Manual inventory transfer loops <code>opengothic.inventory.transferAll</code>, <code>transferByPredicate</code> Standardized filtering and result shape Repeated nearest-NPC scan code <code>opengothic.worldutil.findNearestNpc</code> Reusable and predicate-aware"},{"location":"daedalus-bridge/migration-map/#when-direct-bridge-calls-are-still-correct","title":"When Direct Bridge Calls Are Still Correct","text":"<p>Use <code>opengothic.daedalus.call(...)</code> or <code>opengothic.vm.callWithContext(...)</code> when:</p> <ol> <li>No convenience wrapper exists yet.</li> <li>You must preserve exact non-external Daedalus function behavior.</li> <li>You are doing staged migration and need temporary interop.</li> </ol> <p>Do not plan on raw bridge calls for external symbols yet; those paths are currently unsupported.</p>"},{"location":"daedalus-bridge/migration-map/#prefer-safe-bridge-wrappers-for-transitional-code","title":"Prefer Safe Bridge Wrappers for Transitional Code","text":"<p>For migration phases where direct bridge calls are still required, prefer:</p> <ul> <li><code>opengothic.daedalus.tryCall(...)</code> instead of raw <code>daedalus.call(...)</code> in non-critical paths.</li> <li><code>opengothic.daedalus.trySet(...)</code> instead of raw <code>daedalus.set(...)</code> when failure should not abort script execution.</li> <li><code>opengothic.vm.callContextSafe(...)</code> / <code>callSelf(...)</code> / <code>callSelfOther(...)</code> for context-driven calls.</li> </ul> <p>This keeps legacy interop robust while you gradually move to high-level wrappers.</p>"},{"location":"daedalus-bridge/migration-map/#porting-strategy","title":"Porting Strategy","text":"<ol> <li>Keep direct bridge calls in one module (<code>bridge_compat.lua</code> style).</li> <li>Replace mapped calls with wrappers from this page.</li> <li>Add <code>pcall</code> around remaining direct bridge sites.</li> <li>Move persistent state to <code>opengothic.storage</code>.</li> <li>Keep only unavoidable <code>daedalus.call</code> uses.</li> </ol>"},{"location":"daedalus-bridge/migration-map/#related-pages","title":"Related Pages","text":"<ul> <li>Contracts</li> <li>Internals</li> <li>Recipes</li> <li>API Reference: Globals</li> </ul>"},{"location":"daedalus-bridge/recipes/","title":"Daedalus Bridge Recipes","text":"<p>These recipes assume you already know Daedalus and want robust Lua-side interop patterns.</p>"},{"location":"daedalus-bridge/recipes/#recipe-1-use-built-in-non-throwing-bridge-wrappers","title":"Recipe 1: Use Built-In Non-Throwing Bridge Wrappers","text":"<p>Prefer the built-in wrappers over ad-hoc <code>pcall</code> wrappers:</p> <pre><code>local ok, result, err = opengothic.daedalus.tryCall(\"B_GivePlayerXP\", 250)\nif not ok then\n    print(\"[bridge] B_GivePlayerXP failed: \" .. tostring(err))\nend\n\nlocal setOk, setErr = opengothic.daedalus.trySet(\"MY_QUEST_STATE\", 2)\nif not setOk then\n    print(\"[bridge] MY_QUEST_STATE write failed: \" .. tostring(setErr))\nend\n</code></pre> <p>Use these helpers when partial failure is acceptable and you do not want script termination.</p>"},{"location":"daedalus-bridge/recipes/#recipe-2-call-ai-state-with-explicit-context","title":"Recipe 2: Call AI State with Explicit Context","text":"<pre><code>local function forceAttack(attacker, target)\n    if not attacker or not target then\n        return false\n    end\n\n    local ok, _, err = opengothic.vm.callSelfOther(\"ZS_Attack\", attacker, target)\n    if not ok then\n        print(\"[bridge] ZS_Attack failed: \" .. tostring(err))\n        return false\n    end\n\n    return true\nend\n</code></pre> <p>Use this when a Daedalus function depends on <code>SELF</code>/<code>OTHER</code> semantics.</p>"},{"location":"daedalus-bridge/recipes/#recipe-3-register-lua-external-for-daedalus-trigger","title":"Recipe 3: Register Lua External for Daedalus Trigger","text":"<p>Lua side:</p> <pre><code>opengothic.vm.registerExternal(\"Lua_OnSpecialLever\", function()\n    local player = opengothic.player()\n    if not player then\n        return 0\n    end\n\n    if player:level() &gt;= 10 then\n        opengothic.ui.notify(\"The mechanism responds.\")\n        return 1\n    end\n\n    opengothic.ui.notify(\"You are not experienced enough.\")\n    return 0\nend)\n</code></pre> <p>Daedalus side declaration/call:</p> <pre><code>func int Lua_OnSpecialLever();\n\nfunc void ON_LEVER_TRIGGER() {\n    var int result;\n    result = Lua_OnSpecialLever();\n    if (result == 1) {\n        // follow-up logic\n    };\n};\n</code></pre> <p>Current bridge limitation: Lua external callback is invoked without arguments.</p>"},{"location":"daedalus-bridge/recipes/#recipe-4-enumerate-symbol-class-for-diagnostics","title":"Recipe 4: Enumerate Symbol Class for Diagnostics","text":"<pre><code>local count = 0\n\nopengothic.vm.enumerate(\"C_NPC\", function(symbol)\n    count = count + 1\n    if count &lt;= 20 then\n        print(\"[C_NPC] \" .. symbol.name .. \" (#\" .. tostring(symbol.index) .. \")\")\n    end\n    return true\nend)\n\nprint(\"[C_NPC] total scanned: \" .. tostring(count))\n</code></pre> <p>Use this for migration audits and symbol sanity checks.</p>"},{"location":"daedalus-bridge/recipes/#recipe-5-prefer-convenience-api-first-bridge-as-fallback","title":"Recipe 5: Prefer Convenience API First, Bridge as Fallback","text":"<pre><code>local function giveItemCompat(npc, itemSymbol, count)\n    count = count or 1\n\n    -- Preferred path\n    local ok = npc:giveItem(itemSymbol, count)\n    return ok\nend\n</code></pre> <p>Use convenience APIs directly for gameplay helpers that no longer rely on raw external passthrough.</p>"},{"location":"daedalus-bridge/recipes/#recipe-6-session-aware-symbol-cache","title":"Recipe 6: Session-Aware Symbol Cache","text":"<pre><code>local HERO_ID = nil\n\nlocal function refreshSymbolCache()\n    HERO_ID = opengothic.resolve(\"PC_HERO\")\nend\n\nopengothic.events.register(\"onWorldLoaded\", function()\n    refreshSymbolCache()\n    return false\nend)\n</code></pre> <p>For bridge-heavy mods, refresh cached symbol IDs on <code>onWorldLoaded</code> instead of assuming static IDs before session start.</p>"},{"location":"daedalus-bridge/recipes/#recipe-7-incremental-migration-with-trycall-callselfother","title":"Recipe 7: Incremental Migration with <code>tryCall</code> + <code>callSelfOther</code>","text":"<pre><code>local function runLegacyAttack(attacker, target)\n    -- 1) Prefer higher-level wrapper when behavior is equivalent\n    local ok, err = opengothic.ai.attackTarget(attacker, target)\n    if ok then\n        return true\n    end\n\n    -- 2) Fallback to exact Daedalus AI state with safe context wrapper\n    local ctxOk, _, ctxErr = opengothic.vm.callSelfOther(\"ZS_Attack\", attacker, target)\n    if ctxOk then\n        return true\n    end\n\n    -- 3) Optional legacy side-effect call without throwing\n    local callOk, _, callErr = opengothic.daedalus.tryCall(\"MY_LEGACY_ATTACK_HELPER\", attacker, target)\n    if not callOk then\n        print(\"[bridge] fallback failed: \" .. tostring(ctxErr) .. \" / \" .. tostring(callErr))\n        return false\n    end\n\n    return false\nend\n</code></pre> <p>This pattern keeps migration robust:</p> <ol> <li>convenience API first</li> <li>context-safe bridge fallback</li> <li>non-throwing legacy call path</li> </ol>"},{"location":"daedalus-bridge/troubleshooting/","title":"Daedalus Bridge Troubleshooting","text":"<p>This page maps common bridge failures to exact causes and fixes.</p>"},{"location":"daedalus-bridge/troubleshooting/#common-errors","title":"Common Errors","text":"Error message Likely cause Fix <code>daedalus.call: no world loaded</code> Called at script load/menu time Move call into runtime hook (<code>onWorldLoaded</code>, gameplay event) <code>daedalus.set: no world loaded</code> Same as above Same fix as above <code>vm.callWithContext: no world loaded</code> Same as above Same fix as above <code>vm.registerExternal: no world loaded</code> Registration executed before session world exists Register at/after <code>onWorldLoaded</code> <code>daedalus.call: function 'X' not found</code> Symbol name typo or script pack mismatch Check symbol name and loaded DAT/scripts <code>daedalus.call: error calling 'X': external function is not supported by the current bridge ...</code> Target symbol is external Use existing convenience/primitives or wait for external-call bridge extension <code>daedalus.set: symbol 'X' not found</code> Unknown global symbol Verify symbol name exists in current script set <code>daedalus.set: cannot modify const symbol 'X'</code> Attempt to write const Remove write or use mutable variable <code>daedalus.set: index N out of bounds</code> Wrong array index Validate <code>count</code>/index assumptions <code>daedalus.set: expected ...</code> Lua value type mismatch Convert to expected scalar type <code>daedalus.call: unsupported argument type at position ...</code> Passed table/function/boolean to <code>daedalus.call</code> Convert argument to scalar/userdata or wrap differently <code>vm.callWithContext: error calling 'X': ...</code> VM execution failure inside target function Validate context (<code>self/other/...</code>) and argument set"},{"location":"daedalus-bridge/troubleshooting/#prefer-non-throwing-wrapper-paths","title":"Prefer Non-Throwing Wrapper Paths","text":"<p>When runtime errors should not abort script flow, use:</p> <ul> <li><code>opengothic.daedalus.tryCall(...)</code></li> <li><code>opengothic.daedalus.trySet(...)</code></li> <li><code>opengothic.vm.callContextSafe(...)</code></li> <li><code>opengothic.vm.callSelf(...)</code></li> <li><code>opengothic.vm.callSelfOther(...)</code></li> </ul> <p>These wrappers convert bridge exceptions into return values (<code>ok, ..., err</code>) and are useful for migration-heavy mods.</p>"},{"location":"daedalus-bridge/troubleshooting/#silentnon-throwing-pitfalls","title":"Silent/Non-Throwing Pitfalls","text":""},{"location":"daedalus-bridge/troubleshooting/#daedalusget-returns-nil","title":"<code>daedalus.get(...)</code> returns <code>nil</code>","text":"<p><code>nil</code> may mean any of:</p> <ol> <li>No world loaded.</li> <li>Symbol not found.</li> <li>Index out of range.</li> <li>Instance symbol exists but no mapped live runtime object.</li> </ol> <p>Add explicit guards:</p> <pre><code>local world = opengothic.world()\nif not world then\n    return\nend\n\nlocal value = opengothic.daedalus.get(\"MY_SYMBOL\")\nif value == nil then\n    print(\"[bridge] missing or unavailable symbol\")\nend\n</code></pre>"},{"location":"daedalus-bridge/troubleshooting/#vmenumerate-callback-error-does-not-throw","title":"<code>vm.enumerate(...)</code> callback error does not throw","text":"<p>Callback errors are logged and enumeration stops. Wrap callback body if you need strict behavior:</p> <pre><code>opengothic.vm.enumerate(\"C_ITEM\", function(symbol)\n    local ok, err = pcall(function()\n        -- your logic\n    end)\n    if not ok then\n        print(\"[bridge] enumerate callback failed: \" .. tostring(err))\n    end\n    return true\nend)\n</code></pre>"},{"location":"daedalus-bridge/troubleshooting/#debug-checklist-for-bridge-calls","title":"Debug Checklist for Bridge Calls","text":"<ol> <li>Is a world/session loaded?</li> <li>Does symbol/function name exist in the current script set?</li> <li>Are you passing bridge-compatible argument types?</li> <li>Do you need explicit context (<code>self</code>, <code>other</code>, <code>victim</code>, <code>item</code>)?</li> <li>Are you accidentally using bridge calls where an existing convenience wrapper is better?</li> </ol>"},{"location":"daedalus-bridge/troubleshooting/#migration-stability-checklist","title":"Migration Stability Checklist","text":"<ol> <li>Keep direct bridge calls centralized in one module.</li> <li>Wrap direct calls with <code>pcall</code> where failure should not abort script flow.</li> <li>Replace mapped legacy calls with convenience wrappers from Migration Map.</li> <li>Store persistent mod state in <code>opengothic.storage</code>, not Daedalus globals.</li> <li>Re-test after save/load transitions because Daedalus VM is session-scoped.</li> </ol>"},{"location":"getting-started/","title":"Getting Started with Lua Modding","text":"<p>This section is the shortest path from zero setup to a working OpenGothic Lua script.</p>"},{"location":"getting-started/#what-you-need","title":"What You Need","text":"<ul> <li>OpenGothic running locally.</li> <li>Write access to your game directory.</li> <li>Basic Lua syntax knowledge (<code>local</code>, functions, tables).</li> </ul>"},{"location":"getting-started/#script-location-and-load-model","title":"Script Location and Load Model","text":"<p>OpenGothic loads all <code>.lua</code> files from:</p> <p><code>Data/opengothic/scripts/</code></p> <p>The directory is scanned recursively.</p> <pre><code>Gothic2/\n\u2514\u2500\u2500 Data/\n    \u2514\u2500\u2500 opengothic/\n        \u2514\u2500\u2500 scripts/\n            \u251c\u2500\u2500 health_monitor.lua\n            \u2514\u2500\u2500 my_mod/\n                \u251c\u2500\u2500 init.lua\n                \u2514\u2500\u2500 helpers.lua\n</code></pre> <p>All files share one Lua VM/global environment. Use <code>local</code> by default and prefix persistent storage keys to avoid collisions with other mods.</p>"},{"location":"getting-started/#api-surface-at-a-glance","title":"API Surface at a Glance","text":"<p>The scripting API is exposed through the global <code>opengothic</code> table.</p> <ul> <li>Event hooks: <code>opengothic.events.register(...)</code></li> <li>World and player access: <code>opengothic.world()</code>, <code>opengothic.player()</code></li> <li>Constants and enums: <code>opengothic.CONSTANTS</code></li> <li>Save-safe mod state: <code>opengothic.storage</code></li> <li>Convenience namespaces: <code>opengothic.quest</code>, <code>opengothic.dialog</code>, <code>opengothic.ai</code>, <code>opengothic.timer</code>, <code>opengothic.ui</code></li> </ul> <p>See the API Reference for full details.</p>"},{"location":"getting-started/#output-channels","title":"Output Channels","text":"<p>Use output channels intentionally:</p> <ul> <li><code>print(...)</code> or <code>opengothic.ui.debug(...)</code> for developer/test logs (stdout).</li> <li><code>opengothic.ui.notify(...)</code> or <code>opengothic.printMessage(...)</code> for player-facing in-game messages.</li> </ul> <pre><code>print(\"[my_mod] loaded\")\nopengothic.ui.notify(\"Quest updated\")\n</code></pre>"},{"location":"getting-started/#learning-path","title":"Learning Path","text":"<ol> <li>Start with Your First Mod.</li> <li>Continue with Quickloot, Auto Pickup, or Creating a Simple Quest.</li> <li>Then move to Core Concepts to choose between primitives and convenience APIs.</li> </ol>"},{"location":"getting-started/tutorials/auto-pickup/","title":"Tutorial: Auto Pickup","text":"<p>This tutorial implements automatic pickup of nearby world items for the player.</p> <p>Our script will:</p> <ol> <li>Periodically scan for the nearest item around the player.</li> <li>Filter pickup candidates (for example mission-item exclusion).</li> <li>Move the item into player inventory and remove it from the world.</li> <li>Start and stop cleanly across world/session lifecycle events.</li> </ol>"},{"location":"getting-started/tutorials/auto-pickup/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file:</p> <p>File Location: <code>Data/opengothic/scripts/auto_pickup.lua</code></p>"},{"location":"getting-started/tutorials/auto-pickup/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>auto_pickup.lua</code> and add:</p> <pre><code>-- auto_pickup.lua\n\nlocal PICKUP_RANGE = 180\nlocal PICKUP_INTERVAL_SECONDS = 0.25\nlocal ALLOW_MISSION_ITEMS = false\nlocal SHOW_PICKUP_MESSAGES = true\n\nlocal pickupTimerId = nil\n\nlocal function notify(text)\n    local ok = opengothic.ui.notify(text)\n    if not ok then\n        opengothic.printMessage(text)\n    end\nend\n\nlocal function isPickupCandidate(item)\n    if not ALLOW_MISSION_ITEMS and item:isMission() then\n        return false\n    end\n    return true\nend\n\nlocal function stopAutoPickupTimer()\n    if pickupTimerId then\n        opengothic.timer.cancel(pickupTimerId)\n        pickupTimerId = nil\n    end\nend\n\nlocal function tryAutoPickup()\n    local player = opengothic.player()\n    if not player then\n        return\n    end\n\n    local world = player:world()\n    local inventory = player:inventory()\n    if not world or not inventory then\n        return\n    end\n\n    local item = opengothic.worldutil.findNearestItem(player, PICKUP_RANGE, isPickupCandidate)\n    if not item then\n        return\n    end\n\n    local itemId = item:clsId()\n    local count = item:count()\n    if count &lt;= 0 then\n        return\n    end\n\n    local added = inventory:addItem(itemId, count)\n    if not added then\n        print(\"[auto_pickup] addItem failed for item id \" .. tostring(itemId))\n        return\n    end\n\n    world:removeItem(item)\n\n    if SHOW_PICKUP_MESSAGES then\n        notify(\"Auto-picked \" .. tostring(added:count()) .. \"x \" .. added:displayName())\n    end\nend\n\nlocal function startAutoPickupTimer()\n    stopAutoPickupTimer()\n\n    local timerId, err = opengothic.timer.every(PICKUP_INTERVAL_SECONDS, function(_)\n        local ok, tickErr = pcall(tryAutoPickup)\n        if not ok then\n            print(\"[auto_pickup] tick failed: \" .. tostring(tickErr))\n        end\n    end)\n\n    if not timerId then\n        print(\"[auto_pickup] timer start failed: \" .. tostring(err))\n        return\n    end\n\n    pickupTimerId = timerId\nend\n\nopengothic.events.register(\"onWorldLoaded\", function()\n    startAutoPickupTimer()\n    return false\nend)\n\nopengothic.events.register(\"onSessionExit\", function()\n    stopAutoPickupTimer()\n    return false\nend)\n\nprint(\"auto_pickup loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/auto-pickup/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation combines timer and world utility helpers:</p> <ul> <li><code>opengothic.timer.every(...)</code>:</li> <li>Runs a periodic check without requiring an <code>onUpdate</code> handler in your script.</li> <li><code>opengothic.worldutil.findNearestItem(...)</code>:</li> <li>Finds the nearest item near the player.</li> <li>Uses a predicate (<code>isPickupCandidate</code>) to filter items.</li> <li><code>inventory:addItem(...)</code> + <code>world:removeItem(...)</code>:</li> <li>Adds to inventory first, then removes the world instance to avoid accidental loss on add failure.</li> </ul>"},{"location":"getting-started/tutorials/auto-pickup/#candidate-filtering","title":"Candidate filtering","text":"<ul> <li><code>ALLOW_MISSION_ITEMS = false</code> prevents auto-looting mission items by default.</li> <li>Extend <code>isPickupCandidate(item)</code> if your mod needs stricter rules (for example only gold or only ammo).</li> </ul>"},{"location":"getting-started/tutorials/auto-pickup/#lifecycle-safety","title":"Lifecycle safety","text":"<ul> <li><code>onWorldLoaded</code>: restarts timer for the active world.</li> <li><code>onSessionExit</code>: cancels timer to avoid stale periodic callbacks across sessions.</li> </ul>"},{"location":"getting-started/tutorials/auto-pickup/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Start or load a game.</li> <li>Approach a dropped world item.</li> <li>Verify item is automatically moved to inventory within a short interval.</li> <li>Toggle <code>ALLOW_MISSION_ITEMS</code> and confirm mission-item behavior changes.</li> </ol> <p>If pickup is too aggressive, increase <code>PICKUP_INTERVAL_SECONDS</code> or reduce <code>PICKUP_RANGE</code>.</p>"},{"location":"getting-started/tutorials/auto-pickup/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Quickloot</li> <li>Your First Mod</li> <li>Cowardly Scavengers</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/","title":"Tutorial: Creating a Simple Quest","text":"<p>This tutorial walks through a small quest with three phases:</p> <ol> <li>Start the quest by talking to a specific NPC.</li> <li>Progress the quest by picking up a target item.</li> <li>Complete the quest by returning to the NPC with that item.</li> </ol> <p>The script uses <code>opengothic.quest.*</code> convenience APIs and stores progress in <code>opengothic.storage</code> so save/load is handled correctly.</p>"},{"location":"getting-started/tutorials/creating-a-quest/#step-1-setup-symbols-and-create-your-script","title":"Step 1: Setup Symbols and Create Your Script","text":"<p>Before writing quest logic, choose symbols that definitely exist in your current game/scripts.</p> <p>Recommended first pass (Gothic 2 NoTR):</p> <ul> <li>Xardas NPC symbol: <code>NONE_100_XARDAS</code></li> <li>Quest item symbol: <code>ITPO_HEALTH_01</code></li> </ul> <p>If you want a different NPC, use a short probe script first:</p> <p>File Location: <code>Data/opengothic/scripts/xardas_probe.lua</code></p> <pre><code>opengothic.events.register(\"onDialogStart\", function(npc, player)\n    local id = npc:instanceId()\n    local symbol = nil\n    opengothic.vm.enumerate(\"\", function(sym)\n        if sym.index == id then\n            symbol = sym.name\n            return false\n        end\n        return true\n    end)\n\n    print(\"[xardas_probe] dialog with: \" .. npc:displayName()\n        .. \" | id=\" .. tostring(id)\n        .. \" | symbol=\" .. tostring(symbol))\n    return false\nend)\n</code></pre> <p>Talk to your target NPC once and copy the printed <code>symbol=...</code> value into <code>XARDAS_NPC_SYMBOL</code>.</p>"},{"location":"getting-started/tutorials/creating-a-quest/#probe-explanation","title":"Probe Explanation","text":"<ul> <li><code>npc:instanceId()</code> gives the Daedalus symbol index for the currently speaking NPC.</li> <li><code>opengothic.vm.enumerate(\"\", ...)</code> walks known symbols; the probe matches by <code>sym.index</code>.</li> <li>The printed <code>symbol=...</code> is the string you should use in <code>npc:isInstance(...)</code> checks.</li> </ul> <p>Now create the quest script file:</p> <p>File Location: <code>Data/opengothic/scripts/my_first_quest.lua</code></p>"},{"location":"getting-started/tutorials/creating-a-quest/#step-2-define-quest-logic","title":"Step 2: Define Quest Logic","text":"<p>Open <code>my_first_quest.lua</code> and add:</p> <pre><code>-- my_first_quest.lua\n\nlocal QUEST_TOPIC_NAME = \"An Apple a day keeps Xardas at bay...\"\nlocal XARDAS_NPC_SYMBOL = \"NONE_100_XARDAS\"\nlocal XARDAS_ITEM_SYMBOL = \"ITPO_HEALTH_01\"\nlocal STAGE_KEY = \"my_first_quest.stage\"\n\nlocal missingScrollId = nil\n\nlocal function notify(text)\n    local ok = opengothic.ui.notify(text)\n    if not ok then\n        opengothic.printMessage(text)\n    end\nend\n\nlocal function getStage()\n    local stage = opengothic.storage[STAGE_KEY]\n    if type(stage) ~= \"number\" then\n        return 0\n    end\n    return stage\nend\n\nlocal function setStage(stage)\n    opengothic.storage[STAGE_KEY] = stage\nend\n\nlocal function refreshSymbols()\n    -- resolve() requires an active world/session\n    missingScrollId = opengothic.resolve(XARDAS_ITEM_SYMBOL)\n    print(\"[my_first_quest] configured item=\" .. tostring(XARDAS_ITEM_SYMBOL)\n        .. \" resolvedId=\" .. tostring(missingScrollId))\nend\n\nlocal function startQuest()\n    if getStage() ~= 0 then\n        return\n    end\n\n    notify(\"New Quest: An Apple a day keeps Xardas at bay...\")\n    opengothic.quest.create(QUEST_TOPIC_NAME, opengothic.quest.SECTION.MISSIONS)\n    opengothic.quest.addEntry(QUEST_TOPIC_NAME, \"Xardas looks like he argued with twenty demons and lost sleep to all of them. He wants an Essence of Healing, now.\")\n    opengothic.quest.setState(QUEST_TOPIC_NAME, opengothic.quest.STATUS.RUNNING)\n    setStage(1)\nend\n\nlocal function progressQuest()\n    if getStage() ~= 1 then\n        return\n    end\n\n    notify(\"Quest Update: Medicine for the old necromancer\")\n    opengothic.quest.addEntry(QUEST_TOPIC_NAME, \"I found an Essence of Healing near Xardas' place. If I bring it quickly, maybe he stops cursing apprentices for a minute.\")\n    setStage(2)\nend\n\nlocal function completeQuest()\n    if getStage() ~= 2 then\n        return\n    end\n\n    notify(\"Quest Complete: Xardas survives another day\")\n    opengothic.quest.addEntry(QUEST_TOPIC_NAME, \"Xardas drank the potion without thanks, muttered that I am useful for once, and went back to brooding over ancient disasters.\")\n    opengothic.quest.setState(QUEST_TOPIC_NAME, opengothic.quest.STATUS.SUCCESS)\n    setStage(3)\nend\n\n-- Re-resolve symbols whenever a world is loaded\nopengothic.events.register(\"onWorldLoaded\", function()\n    refreshSymbols()\n    return false\nend)\n\n-- New game: reset tutorial quest stage\nopengothic.events.register(\"onStartGame\", function(worldName)\n    setStage(0)\n    refreshSymbols()\n    print(\"[my_first_quest] initialized in world \" .. tostring(worldName))\n    return false\nend)\n\n-- Load game: keep stage from storage, only refresh cached symbol IDs\nopengothic.events.register(\"onLoadGame\", function(saveName)\n    refreshSymbols()\n    print(\"[my_first_quest] loaded save \" .. tostring(saveName) .. \" at stage \" .. tostring(getStage()))\n    return false\nend)\n\n-- Start or complete the quest by talking to the configured NPC\nopengothic.events.register(\"onDialogStart\", function(npc, player)\n    if not npc:isInstance(XARDAS_NPC_SYMBOL) then\n        return false\n    end\n\n    local stage = getStage()\n    if stage == 0 then\n        startQuest()\n    elseif stage == 2 then\n        if opengothic.inventory.hasItem(player, XARDAS_ITEM_SYMBOL) then\n            completeQuest()\n        end\n    end\n\n    return false\nend)\n\n-- Progress quest when player picks up the target item\nopengothic.events.register(\"onItemPickup\", function(npc, item)\n    if not npc:isPlayer() or getStage() ~= 1 then\n        return false\n    end\n\n    if missingScrollId == nil then\n        refreshSymbols()\n    end\n\n    if missingScrollId and item:clsId() == missingScrollId then\n        progressQuest()\n    end\n\n    return false\nend)\n\nprint(\"my_first_quest loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/creating-a-quest/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation uses quest hooks and save-safe state handling:</p> <ul> <li><code>opengothic.quest.*</code>:</li> <li>Used to create the topic, add entries, and set status.</li> <li><code>opengothic.storage</code>:</li> <li>Stores the quest stage under <code>my_first_quest.stage</code>, so progress survives save/load.</li> <li><code>refreshSymbols()</code>:</li> <li>Re-resolves IDs after world/session events because <code>opengothic.resolve(...)</code> requires an active world.</li> <li>Prints the resolved item ID so setup mistakes are visible immediately.</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/#onstartgame-and-onloadgame","title":"<code>onStartGame</code> and <code>onLoadGame</code>","text":"<ul> <li><code>onStartGame</code>: resets stage to <code>0</code> for a new playthrough.</li> <li><code>onLoadGame</code>: keeps stored stage and only refreshes cached IDs.</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/#ondialogstart","title":"<code>onDialogStart</code>","text":"<ul> <li>Starts the quest at stage <code>0</code>.</li> <li>Completes the quest at stage <code>2</code> if <code>opengothic.inventory.hasItem(...)</code> confirms the target item.</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/#onitempickup","title":"<code>onItemPickup</code>","text":"<ul> <li>Advances stage <code>1 -&gt; 2</code> when the configured item is picked up by the player.</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Start a new game.</li> <li>Check logs for <code>my_first_quest loaded</code> and item symbol resolution from <code>refreshSymbols()</code>.</li> <li>Talk to Xardas (<code>NONE_100_XARDAS</code> by default).</li> <li>Verify:<ul> <li><code>New Quest: An Apple a day keeps Xardas at bay...</code> appears.</li> <li>A quest topic is created in the log.</li> </ul> </li> <li>Pick up the configured item (<code>ITPO_HEALTH_01</code> by default).</li> <li>Verify:<ul> <li><code>Quest Update: Medicine for the old necromancer</code> appears.</li> <li>A second quest entry is added.</li> </ul> </li> <li>Talk to Xardas again.</li> <li>Verify:<ul> <li><code>Quest Complete: Xardas survives another day</code> appears.</li> <li>Topic status switches to success.</li> </ul> </li> <li>Save and reload at different stages to confirm persistence.</li> </ol> <p>If a stage does not advance:</p> <ul> <li>Confirm <code>XARDAS_NPC_SYMBOL</code> and <code>XARDAS_ITEM_SYMBOL</code> are valid in your script set.</li> <li>Keep <code>xardas_probe.lua</code> enabled until NPC symbol matching is correct.</li> <li>Watch <code>[my_first_quest] ... resolvedId=...</code> log output to catch unresolved item symbols (<code>nil</code>).</li> </ul>"},{"location":"getting-started/tutorials/creating-a-quest/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Quickloot</li> <li>Dialog Time Windows</li> <li>Custom Damage Logic</li> </ul>"},{"location":"getting-started/tutorials/custom-damage/","title":"Tutorial: Custom Damage Logic","text":"<p>This tutorial shows how to intercept incoming damage and replace it with custom logic.</p> <p>Our script will:</p> <ol> <li>Detect attacks coming from a specific attacker type.</li> <li>Apply a custom poison-style damage profile.</li> <li>Make a specific victim type extra vulnerable.</li> </ol>"},{"location":"getting-started/tutorials/custom-damage/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file:</p> <p>File Location: <code>Data/opengothic/scripts/custom_damage.lua</code></p>"},{"location":"getting-started/tutorials/custom-damage/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>custom_damage.lua</code> and add:</p> <pre><code>-- custom_damage.lua\n\nlocal ATTACKER_SYMBOL = \"PC_HERO\"\nlocal VULNERABLE_SYMBOL = \"SHEEP\"\n\nlocal attackerId = nil\nlocal vulnerableId = nil\nlocal symbolByIndex = {}\n\nlocal function notify(text)\n    local ok = opengothic.ui.notify(text)\n    if not ok then\n        opengothic.printMessage(text)\n    end\nend\n\nlocal function refreshSymbols()\n    symbolByIndex = {}\n    opengothic.vm.enumerate(\"\", function(sym)\n        symbolByIndex[sym.index] = sym.name\n        return true\n    end)\n\n    attackerId = opengothic.resolve(ATTACKER_SYMBOL)\n    vulnerableId = opengothic.resolve(VULNERABLE_SYMBOL)\n    print(\"[custom_damage] attacker=\" .. tostring(ATTACKER_SYMBOL) .. \" -&gt; \" .. tostring(attackerId))\n    print(\"[custom_damage] vulnerable=\" .. tostring(VULNERABLE_SYMBOL) .. \" -&gt; \" .. tostring(vulnerableId))\nend\n\nopengothic.events.register(\"onWorldLoaded\", function()\n    refreshSymbols()\n    return false\nend)\n\nlocal function buildDamageTable(baseDamage)\n    local dmg = {}\n    for i = 0, opengothic.CONSTANTS.Protection.PROT_MAX - 1 do\n        dmg[i] = 0\n    end\n\n    -- Split poison-like custom damage across magic and fire channels.\n    dmg[opengothic.CONSTANTS.Protection.PROT_MAGIC] = math.floor(baseDamage / 2)\n    dmg[opengothic.CONSTANTS.Protection.PROT_FIRE] = baseDamage - dmg[opengothic.CONSTANTS.Protection.PROT_MAGIC]\n    return dmg\nend\n\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, incomingIsSpell, spellId)\n    if attackerId == nil or vulnerableId == nil then\n        refreshSymbols()\n    end\n\n    -- Not our attacker: keep default engine damage flow.\n    if not attackerId or attacker:instanceId() ~= attackerId then\n        return false\n    end\n\n    local baseDamage = 20\n\n    -- Selected victim type takes triple poison damage.\n    if vulnerableId and victim:instanceId() == vulnerableId then\n        baseDamage = baseDamage * 3\n    end\n\n    local damageTable = buildDamageTable(baseDamage)\n\n    local finalDamage, hasHit = opengothic.DamageCalculator.damageValue(\n        attacker,\n        victim,\n        true, -- force custom spell-table path so our damageTable is always used\n        damageTable\n    )\n\n    local attackerSymbol = symbolByIndex[attacker:instanceId()]\n    local victimSymbol = symbolByIndex[victim:instanceId()]\n    local fireProt = victim:protection(opengothic.CONSTANTS.Protection.PROT_FIRE)\n    local magicProt = victim:protection(opengothic.CONSTANTS.Protection.PROT_MAGIC)\n    print(\n        \"[custom_damage] attacker=\" .. tostring(attackerSymbol)\n        .. \" victim=\" .. tostring(victimSymbol)\n        .. \" incomingIsSpell=\" .. tostring(incomingIsSpell)\n        .. \" forcedSpellPath=true\"\n        .. \" base=\" .. tostring(baseDamage)\n        .. \" fireProt=\" .. tostring(fireProt)\n        .. \" magicProt=\" .. tostring(magicProt)\n        .. \" final=\" .. tostring(finalDamage)\n        .. \" hit=\" .. tostring(hasHit)\n    )\n\n    if hasHit and finalDamage &gt; 0 then\n        victim:changeAttribute(opengothic.CONSTANTS.Attribute.ATR_HITPOINTS, -finalDamage, true)\n        notify(victim:displayName() .. \" took \" .. tostring(finalDamage) .. \" poison damage\")\n    else\n        notify(victim:displayName() .. \" resisted poison damage\")\n    end\n\n    return true -- we handled this damage event; skip default damage path\nend)\n\nprint(\"custom_damage loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/custom-damage/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation uses event interception and the damage helper API:</p> <ul> <li><code>onNpcTakeDamage</code>:</li> <li>Called before default damage handling.</li> <li>Returning <code>true</code> means your script fully handled damage and blocks default processing.</li> <li><code>opengothic.DamageCalculator.damageValue(...)</code>:</li> <li>Evaluates your custom per-type damage table against target protections.</li> <li>Returns <code>finalDamage, hasHit</code>.</li> <li>This tutorial forces the spell-table path (<code>isSpell=true</code>) so the custom table is applied for every incoming hit.</li> <li><code>victim:changeAttribute(...)</code>:</li> <li>Applies final HP change after your custom calculation.</li> </ul>"},{"location":"getting-started/tutorials/custom-damage/#symbol-resolution","title":"Symbol resolution","text":"<ul> <li>IDs are resolved via <code>opengothic.resolve(...)</code>.</li> <li><code>refreshSymbols()</code> is called on <code>onWorldLoaded</code> and lazily in the damage handler to stay robust across sessions.</li> <li>This tutorial uses concrete defaults that work in normal Gothic 2 starts:</li> <li><code>ATTACKER_SYMBOL = \"PC_HERO\"</code></li> <li><code>VULNERABLE_SYMBOL = \"SHEEP\"</code></li> <li><code>refreshSymbols()</code> also builds an index-to-symbol map so debug output can print symbol names for attacker/victim.</li> </ul>"},{"location":"getting-started/tutorials/custom-damage/#custom-damage-table","title":"Custom damage table","text":"<ul> <li>Damage table indices map to <code>opengothic.CONSTANTS.Protection</code>.</li> <li>This example splits custom damage between <code>PROT_MAGIC</code> and <code>PROT_FIRE</code>.</li> <li>Debug output includes victim <code>PROT_MAGIC</code>/<code>PROT_FIRE</code> values so final-damage results are explainable from logs.</li> </ul>"},{"location":"getting-started/tutorials/custom-damage/#blocking-default-damage","title":"Blocking default damage","text":"<ul> <li>This tutorial intentionally uses <code>return true</code> after custom application.</li> <li>If you return <code>false</code>, the default engine damage path will also run.</li> </ul>"},{"location":"getting-started/tutorials/custom-damage/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Start or load a game and check logs for:<ul> <li><code>[custom_damage] attacker=PC_HERO -&gt; ...</code></li> <li><code>[custom_damage] vulnerable=SHEEP -&gt; ...</code></li> </ul> </li> <li>Attack any NPC as the player and verify poison messages appear.</li> <li>Attack a <code>SHEEP</code> (near Xardas' tower start area) and verify damage is higher than normal targets.</li> <li>Check stdout log lines for each hit:<ul> <li>attacker symbol</li> <li>victim symbol</li> <li>base damage</li> <li>final damage</li> <li>hit result</li> </ul> </li> <li>Temporarily change <code>return true</code> to <code>return false</code> to observe default+custom stacking behavior (for testing only).</li> </ol>"},{"location":"getting-started/tutorials/custom-damage/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Cowardly Scavengers</li> <li>Quickloot</li> <li>Creating a Simple Quest</li> </ul>"},{"location":"getting-started/tutorials/dialog-time-windows/","title":"Tutorial: Dialog Time Windows","text":"<p>This tutorial combines both time-gating approaches for dialog:</p> <ol> <li>Block an NPC's entire dialog outside a time range.</li> <li>Hide specific dialog options outside configured windows.</li> </ol>"},{"location":"getting-started/tutorials/dialog-time-windows/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file:</p> <p>File Location: <code>Data/opengothic/scripts/dialog_time_windows.lua</code></p>"},{"location":"getting-started/tutorials/dialog-time-windows/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>dialog_time_windows.lua</code> and add:</p> <pre><code>-- dialog_time_windows.lua\n\nlocal NIGHT_NPC_SYMBOL = \"NONE_100_XARDAS\"\n\n-- Entire dialog allowed only between 20:00 and 06:00\nlocal DIALOG_WINDOW = {\n    startH = 20, startM = 0,\n    endH = 6, endM = 0\n}\n\n-- Per-option time windows\nlocal OPTION_WINDOWS = {\n    INFO_SECRETQUEST_START = {startH = 20, startM = 0, endH = 6, endM = 0},\n    INFO_MERCHANT_RAREITEMS = {startH = 8, startM = 0, endH = 18, endM = 0},\n    INFO_GUARD_RUMORS = {startH = 12, startM = 0, endH = 13, endM = 0},\n}\n\nlocal function notify(text)\n    local ok = opengothic.ui.notify(text)\n    if not ok then\n        opengothic.printMessage(text)\n    end\nend\n\nlocal function refreshSymbols()\n    local npcId = opengothic.resolve(NIGHT_NPC_SYMBOL)\n    print(\"[dialog_time_windows] npc=\" .. tostring(NIGHT_NPC_SYMBOL) .. \" -&gt; \" .. tostring(npcId))\nend\n\nopengothic.events.register(\"onWorldLoaded\", function()\n    refreshSymbols()\n    return false\nend)\n\n-- Register option-level windows using the dialog convenience API.\nfor infoName, window in pairs(OPTION_WINDOWS) do\n    local ok, err = opengothic.dialog.setOptionTimeWindow(\n        infoName,\n        window.startH, window.startM,\n        window.endH, window.endM\n    )\n    if not ok then\n        print(\"[dialog_time_windows] failed to register option window for \" .. infoName .. \": \" .. tostring(err))\n    end\nend\n\n-- Block full dialog for one NPC outside the configured time window.\nopengothic.events.register(\"onDialogStart\", function(npc, player)\n    if not npc:isInstance(NIGHT_NPC_SYMBOL) then\n        return false\n    end\n\n    if not opengothic.dialog.canTalkTo(npc) then\n        return true\n    end\n\n    local world = opengothic.world()\n    if not world then\n        return false\n    end\n\n    local hour, minute = world:time()\n    local clock = string.format(\"%02d:%02d\", hour, minute)\n\n    if world:isTime(\n        DIALOG_WINDOW.startH, DIALOG_WINDOW.startM,\n        DIALOG_WINDOW.endH, DIALOG_WINDOW.endM\n    ) then\n        print(\"[dialog_time_windows] \" .. clock .. \" allow dialog for \" .. NIGHT_NPC_SYMBOL)\n        return false -- inside time window: allow dialog\n    end\n\n    print(\"[dialog_time_windows] \" .. clock .. \" block dialog for \" .. NIGHT_NPC_SYMBOL)\n    notify(npc:displayName() .. \" is unavailable at this hour.\")\n    return true -- outside time window: block dialog\nend)\n\nprint(\"dialog_time_windows loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/dialog-time-windows/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation uses the dialog convenience APIs plus one lifecycle hook:</p> <ul> <li><code>opengothic.dialog.setOptionTimeWindow(...)</code>:</li> <li>Registers time windows for specific <code>INFO_*</code> dialog options.</li> <li>Option is visible inside the window and hidden outside it.</li> <li><code>onDialogStart</code>:</li> <li>Used for whole-dialog gating of a specific NPC.</li> <li>Returning <code>true</code> blocks the dialog start.</li> <li><code>opengothic.dialog.canTalkTo(npc)</code>:</li> <li>Fast guard for invalid/non-talkable NPC states.</li> </ul>"},{"location":"getting-started/tutorials/dialog-time-windows/#full-dialog-gating","title":"Full-dialog gating","text":"<ul> <li>Uses <code>npc:isInstance(...)</code> to target one NPC.</li> <li>Uses <code>world:isTime(...)</code> to allow/block by hour window.</li> <li>Shows a user-facing message when blocked.</li> <li>Prints current game time and allow/block decision to stdout for quick verification.</li> </ul>"},{"location":"getting-started/tutorials/dialog-time-windows/#option-level-gating","title":"Option-level gating","text":"<ul> <li>Uses <code>OPTION_WINDOWS</code> config table keyed by <code>INFO_*</code> option names.</li> <li>Registers all option windows once at script load.</li> <li>No custom <code>onDialogOption</code> callback is required for basic time windows.</li> </ul>"},{"location":"getting-started/tutorials/dialog-time-windows/#finding-option-names","title":"Finding option names","text":"<p>If you need option symbol names for your own dialogs:</p> <pre><code>opengothic.events.register(\"onDialogOption\", function(npc, player, infoName)\n    print(\"Dialog option: \" .. tostring(infoName))\n    return false\nend)\n</code></pre>"},{"location":"getting-started/tutorials/dialog-time-windows/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Start or load a game (the script only works with an active world/session).</li> <li>Check logs for:<ul> <li><code>dialog_time_windows loaded</code></li> <li><code>[dialog_time_windows] npc=NONE_100_XARDAS -&gt; ...</code></li> </ul> </li> <li>Talk to <code>NONE_100_XARDAS</code> at night (20:00-06:00): dialog should open normally.</li> <li>Talk to <code>NONE_100_XARDAS</code> outside that window (for example 12:00): dialog should be blocked with an unavailable message. Also check stdout:<ul> <li><code>... allow dialog ...</code> inside window</li> <li><code>... block dialog ...</code> outside window</li> </ul> </li> <li>Check configured <code>INFO_*</code> options at different times:<ul> <li>inside their configured windows: option visible</li> <li>outside their configured windows: option hidden</li> </ul> </li> <li>For quick testing, call <code>world:setDayTime(hour, minute)</code> from a temporary helper script or console flow, then retry the same dialog immediately.</li> <li>Gothic 2 start-area tip: there is a bed close to Xardas' tower, so you can sleep to jump time quickly between allowed/disallowed windows.</li> </ol> <p>If nothing changes:</p> <ul> <li>Confirm <code>NIGHT_NPC_SYMBOL</code> matches your target NPC symbol.</li> <li>Confirm your <code>INFO_*</code> names actually exist in your loaded script set.</li> <li>Use the <code>onDialogOption</code> probe shown above to log real option names.</li> </ul>"},{"location":"getting-started/tutorials/dialog-time-windows/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Creating a Simple Quest</li> <li>Quickloot</li> <li>Cowardly Scavengers</li> </ul>"},{"location":"getting-started/tutorials/quickloot/","title":"Tutorial: Implementing Quickloot","text":"<p>This tutorial implements a common modding feature: quickloot. When the player opens containers, ransacks NPCs, or picks up world items, loot is transferred immediately without opening the usual UI.</p> <p>This script quickloots:</p> <ol> <li>Containers and chests.</li> <li>Unconscious/dead NPC inventories.</li> <li>Individual world items.</li> </ol>"},{"location":"getting-started/tutorials/quickloot/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file for your script.</p> <p>File Location: <code>Data/opengothic/scripts/quickloot.lua</code></p>"},{"location":"getting-started/tutorials/quickloot/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>quickloot.lua</code> and paste the following code:</p> <pre><code>-- quickloot.lua\n\nlocal function notify(text)\n    local ok = opengothic.ui.notify(text)\n    if not ok then\n        opengothic.printMessage(text)\n    end\nend\n\nlocal function quicklootInventory(player, sourceInventory, verb)\n    local items, err = opengothic.inventory.transferAll(player, sourceInventory, {\n        includeEquipped = false,\n        includeMission = true\n    })\n\n    if err then\n        print(\"[quickloot] transfer failed: \" .. err)\n        return false\n    end\n\n    if #items == 0 then\n        return false\n    end\n\n    for _, itemRecord in ipairs(items) do\n        notify(verb .. \" \" .. itemRecord.count .. \"x \" .. itemRecord.name)\n    end\n\n    return true\nend\n\n-- Containers/chests\nopengothic.events.register(\"onOpen\", function(player, interactive)\n    if not player:isPlayer() then\n        return false\n    end\n\n    if not interactive:isContainer() then\n        return false\n    end\n\n    if interactive:needToLockpick(player) then\n        return false\n    end\n\n    local sourceInventory = interactive:inventory()\n    if not sourceInventory then\n        return false\n    end\n\n    if quicklootInventory(player, sourceInventory, \"Looted\") then\n        return true -- hide open/ransack UI when loot was transferred\n    end\n\n    return false\nend)\n\n-- Corpses/unconscious NPCs\nopengothic.events.register(\"onRansack\", function(player, target)\n    if not player:isPlayer() then\n        return false\n    end\n\n    local sourceInventory = target:inventory()\n    if not sourceInventory then\n        return false\n    end\n\n    if quicklootInventory(player, sourceInventory, \"Ransacked\") then\n        return true -- hide ransack UI when loot was transferred\n    end\n\n    return false\nend)\n\n-- Individual world items\nopengothic.events.register(\"onItemPickup\", function(npc, item)\n    if not npc:isPlayer() then\n        return false\n    end\n\n    local world = npc:world()\n    local inventory = npc:inventory()\n    if not world or not inventory then\n        return false\n    end\n\n    local itemId = item:clsId()\n    local count = item:count()\n    if count &lt;= 0 then\n        return false\n    end\n\n    -- Add first to avoid item loss if add fails. Then remove world instance.\n    local added = inventory:addItem(itemId, count)\n    if not added then\n        return false\n    end\n\n    world:removeItem(item)\n    notify(\"Picked up \" .. added:count() .. \"x \" .. added:displayName())\n    return true -- block default pickup flow\nend)\n\nprint(\"quickloot loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/quickloot/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation uses the newer convenience APIs where they help:</p> <ul> <li><code>opengothic.inventory.transferAll(...)</code>:</li> <li>Used for both <code>onOpen</code> and <code>onRansack</code>.</li> <li>Returns moved item records plus an error code (<code>items, err</code>), so failure handling is explicit.</li> <li><code>opengothic.ui.notify(...)</code>:</li> <li>Used for player-facing loot messages.</li> <li>Wrapped with fallback to <code>opengothic.printMessage(...)</code>.</li> </ul>"},{"location":"getting-started/tutorials/quickloot/#onopen-containers","title":"<code>onOpen</code> (containers)","text":"<ul> <li>Guards to player-only and container-only interactions.</li> <li>Keeps lockpicking gameplay intact via <code>interactive:needToLockpick(player)</code>.</li> <li>Returns <code>true</code> only when items were actually transferred.</li> </ul>"},{"location":"getting-started/tutorials/quickloot/#onransack-npc-inventories","title":"<code>onRansack</code> (NPC inventories)","text":"<ul> <li>Reuses the same transfer helper for corpses/unconscious targets.</li> <li>Returns <code>true</code> only when there was loot to transfer.</li> </ul>"},{"location":"getting-started/tutorials/quickloot/#onitempickup-world-items","title":"<code>onItemPickup</code> (world items)","text":"<ul> <li>Player-only guard.</li> <li>Adds to inventory first, then removes world item instance.</li> <li>Returns <code>true</code> to block the default pickup flow after manual transfer.</li> </ul>"},{"location":"getting-started/tutorials/quickloot/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test these scenarios:</p> <ol> <li>Open an unlocked container with items: loot should transfer instantly.</li> <li>Ransack an unconscious/dead NPC: loot should transfer instantly.</li> <li>Pick up a world item: item should go directly to inventory with a message.</li> </ol> <p>If you want less message spam, replace per-item notifications with a single summary line in <code>quicklootInventory(...)</code>.</p>"},{"location":"getting-started/tutorials/quickloot/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Creating a Simple Quest</li> <li>Custom Damage Logic</li> <li>Dialog Time Windows</li> </ul>"},{"location":"getting-started/tutorials/scavenger-flee/","title":"Tutorial: Cowardly Scavengers","text":"<p>This tutorial implements a state-driven scavenger behavior: scavengers initially run from the player, then switch to normal combat behavior after the player attacks them.</p> <p>The script does this by combining perception hooks, a flee action with explicit target setup, and a simple retaliate-state toggle.</p> <p>Behavior summary:</p> <ol> <li>Flees from the player on threat perception.</li> <li>Stops fleeing and allows default combat behavior after being hit by the player.</li> <li>Prints detailed debug output so you can verify each state transition.</li> </ol> <p>This version is intentionally simple and deterministic.</p>"},{"location":"getting-started/tutorials/scavenger-flee/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file:</p> <p>File Location: <code>Data/opengothic/scripts/cowardly_scavengers.lua</code></p>"},{"location":"getting-started/tutorials/scavenger-flee/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>cowardly_scavengers.lua</code> and add:</p> <pre><code>-- cowardly_scavengers.lua\n\nlocal SCAVENGER_SYMBOLS = { \"SCAVENGER\", \"YSCAVENGER\" }\nlocal FLEE_COOLDOWN_SECONDS = 0.8\n\nlocal scavengerByInstance = {}\nlocal retaliate = {}  -- key: tostring(npc), value: true after player hit\nlocal nextFleeAt = {} -- key: tostring(npc), value: game runtime seconds\nlocal now = 0.0\n\nlocal THREAT_PERC = 2 -- PERC_ASSESSENEMY\nif opengothic.CONSTANTS and opengothic.CONSTANTS.PercType then\n    THREAT_PERC = opengothic.CONSTANTS.PercType.PERC_ASSESSENEMY or THREAT_PERC\nend\n\nlocal function keyOf(npc)\n    return tostring(npc)\nend\n\nlocal function nameOf(npc)\n    local ok, name = pcall(function()\n        return npc:displayName()\n    end)\n    if ok and type(name) == \"string\" then\n        return name\n    end\n    return \"&lt;?&gt;\"\nend\n\nlocal function instOf(npc)\n    local ok, inst = pcall(function()\n        return npc:instanceId()\n    end)\n    if ok and type(inst) == \"number\" then\n        return inst\n    end\n    return nil\nend\n\nlocal function isPlayer(npc)\n    local ok, value = pcall(function()\n        return npc:isPlayer()\n    end)\n    return ok and value == true\nend\n\nlocal function resolveSymbols()\n    scavengerByInstance = {}\n\n    for _, symbol in ipairs(SCAVENGER_SYMBOLS) do\n        local id = opengothic.resolve(symbol)\n        if type(id) == \"number\" then\n            scavengerByInstance[id] = symbol\n            print(\"[cowardly_scavengers_v1] symbol \" .. symbol .. \" -&gt; \" .. tostring(id))\n        else\n            print(\"[cowardly_scavengers_v1] symbol \" .. symbol .. \" unresolved\")\n        end\n    end\nend\n\nlocal function isScavenger(npc)\n    local inst = instOf(npc)\n    if inst == nil then\n        return false\n    end\n    return scavengerByInstance[inst] ~= nil\nend\n\nopengothic.events.register(\"onUpdate\", function(dt)\n    if type(dt) == \"number\" then\n        now = now + dt\n    end\n    return false\nend)\n\nopengothic.events.register(\"onWorldLoaded\", function()\n    resolveSymbols()\n    retaliate = {}\n    nextFleeAt = {}\n    now = 0.0\n    print(\"[cowardly_scavengers_v1] world loaded; behavior active\")\n    return false\nend)\n\nopengothic.events.register(\"onNpcPerception\", function(npc, other, percType)\n    if not isScavenger(npc) then\n        return false\n    end\n\n    if other == nil or not isPlayer(other) then\n        return false\n    end\n\n    local key = keyOf(npc)\n    local inst = instOf(npc)\n    local mode = retaliate[key] and \"RETALIATE\" or \"COWARD\"\n\n    local okDist, dist = pcall(function()\n        return npc:distanceTo(other)\n    end)\n\n    print(\"[cowardly_scavengers_v1] perception\"\n        .. \" npc=\" .. nameOf(npc)\n        .. \" inst=\" .. tostring(inst)\n        .. \" percType=\" .. tostring(percType)\n        .. \" dist=\" .. tostring(okDist and dist or \"ERR\")\n        .. \" mode=\" .. mode)\n\n    if retaliate[key] then\n        print(\"[cowardly_scavengers_v1] action=ALLOW_DEFAULT reason=retaliate\")\n        return false\n    end\n\n    if percType ~= THREAT_PERC then\n        print(\"[cowardly_scavengers_v1] action=ALLOW_DEFAULT reason=not_threat\")\n        return false\n    end\n\n    local gate = nextFleeAt[key] or 0.0\n    if now &lt; gate then\n        print(\"[cowardly_scavengers_v1] action=BLOCK_DEFAULT reason=cooldown\")\n        return true\n    end\n\n    local okCall, okResult, errResult = pcall(function()\n        return opengothic.ai.fleeFrom(npc, other)\n    end)\n\n    print(\"[cowardly_scavengers_v1] fleeFrom\"\n        .. \" callOk=\" .. tostring(okCall)\n        .. \" result=\" .. tostring(okResult)\n        .. \" err=\" .. tostring(errResult))\n\n    if okCall and okResult == true then\n        nextFleeAt[key] = now + FLEE_COOLDOWN_SECONDS\n        print(\"[cowardly_scavengers_v1] action=FLEE_BLOCK_DEFAULT next=\" .. tostring(nextFleeAt[key]))\n        return true\n    end\n\n    print(\"[cowardly_scavengers_v1] action=ALLOW_DEFAULT reason=flee_failed\")\n    return false\nend)\n\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, isSpell, spellId)\n    if not isScavenger(victim) then\n        return false\n    end\n\n    local key = keyOf(victim)\n    local attackerIsPlayer = attacker ~= nil and isPlayer(attacker)\n\n    print(\"[cowardly_scavengers_v1] damage\"\n        .. \" victim=\" .. nameOf(victim)\n        .. \" attacker=\" .. (attacker and nameOf(attacker) or \"nil\")\n        .. \" attackerIsPlayer=\" .. tostring(attackerIsPlayer)\n        .. \" isSpell=\" .. tostring(isSpell)\n        .. \" spellId=\" .. tostring(spellId))\n\n    if attackerIsPlayer then\n        retaliate[key] = true\n        nextFleeAt[key] = 0.0\n        print(\"[cowardly_scavengers_v1] mode=RETALIATE npc=\" .. nameOf(victim))\n    end\n\n    return false\nend)\n\nopengothic.events.register(\"onNpcDeath\", function(victim, killer, isDeath)\n    if isScavenger(victim) then\n        local key = keyOf(victim)\n        retaliate[key] = nil\n        nextFleeAt[key] = nil\n        print(\"[cowardly_scavengers_v1] cleanup npc=\" .. nameOf(victim) .. \" isDeath=\" .. tostring(isDeath))\n    end\n    return false\nend)\n\nprint(\"cowardly_scavengers loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/scavenger-flee/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This script uses a strict two-mode model:</p> <ul> <li><code>COWARD</code>: scavenger tries to flee from player on threat perception.</li> <li><code>RETALIATE</code>: after the player hits the scavenger, script stops blocking default combat behavior.</li> </ul>"},{"location":"getting-started/tutorials/scavenger-flee/#why-fleefrom-is-used","title":"Why <code>fleeFrom</code> is used","text":"<p><code>opengothic.ai.fleeFrom(npc, target)</code> performs the required setup for reliable fleeing:</p> <ol> <li>Set target.</li> <li>Trigger flee.</li> <li>Keep behavior script-side safe with <code>ok, err</code> return values.</li> </ol>"},{"location":"getting-started/tutorials/scavenger-flee/#why-cooldown-exists","title":"Why cooldown exists","text":"<p><code>onNpcPerception</code> can fire repeatedly for the same NPC. The cooldown prevents action spam while preserving deterministic behavior.</p>"},{"location":"getting-started/tutorials/scavenger-flee/#blocking-behavior-rule","title":"Blocking behavior rule","text":"<p>The hook returns <code>true</code> only when the script successfully handled fleeing. For all other paths it returns <code>false</code> so default engine behavior remains available.</p>"},{"location":"getting-started/tutorials/scavenger-flee/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Start or load a game with scavengers nearby.</li> <li>Verify startup logs:<ul> <li><code>symbol SCAVENGER -&gt; ...</code></li> <li><code>symbol YSCAVENGER -&gt; ...</code></li> <li><code>world loaded; behavior active</code></li> </ul> </li> <li>Approach a scavenger without attacking:<ul> <li>expect <code>mode=COWARD</code></li> <li>expect <code>action=FLEE_BLOCK_DEFAULT</code></li> </ul> </li> <li>Hit the scavenger once:<ul> <li>expect <code>mode=RETALIATE npc=...</code></li> </ul> </li> <li>Stay near after the hit:<ul> <li>expect <code>action=ALLOW_DEFAULT reason=retaliate</code></li> <li>scavenger should use default combat behavior</li> </ul> </li> </ol> <p>If behavior does not match logs, keep the stdout lines and debug one transition at a time.</p>"},{"location":"getting-started/tutorials/scavenger-flee/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Auto Pickup</li> <li>Dialog Time Windows</li> <li>Custom Damage Logic</li> </ul>"},{"location":"getting-started/tutorials/your-first-mod/","title":"Tutorial: Your First Mod (Health Monitor)","text":"<p>This tutorial builds a minimal health monitor script. When the player takes damage, the script logs current and maximum HP to stdout.</p> <p>This script will:</p> <ol> <li>Register one damage event handler.</li> <li>Filter to player-only hits.</li> <li>Log HP values with <code>print(...)</code>.</li> </ol>"},{"location":"getting-started/tutorials/your-first-mod/#step-1-create-your-script-file","title":"Step 1: Create Your Script File","text":"<p>Create a new Lua file:</p> <p>File Location: <code>Data/opengothic/scripts/health_monitor.lua</code></p>"},{"location":"getting-started/tutorials/your-first-mod/#step-2-add-the-lua-code","title":"Step 2: Add the Lua Code","text":"<p>Open <code>health_monitor.lua</code> and add:</p> <pre><code>-- health_monitor.lua\n\nopengothic.events.register(\"onNpcTakeDamage\", function(victim, attacker, isSpell, spellId)\n    if not victim:isPlayer() then\n        return false\n    end\n\n    local currentHp = victim:attribute(opengothic.CONSTANTS.Attribute.ATR_HITPOINTS)\n    local maxHp = victim:attribute(opengothic.CONSTANTS.Attribute.ATR_HITPOINTSMAX)\n\n    print(\"[health_monitor] player HP: \" .. tostring(currentHp) .. \"/\" .. tostring(maxHp))\n    return false -- keep default game damage behavior\nend)\n\nprint(\"health_monitor loaded\")\n</code></pre>"},{"location":"getting-started/tutorials/your-first-mod/#step-3-explanation","title":"Step 3: Explanation","text":"<p>This implementation uses one event hook and one object API call group:</p> <ul> <li><code>onNpcTakeDamage</code>:</li> <li>Triggered before default damage resolution.</li> <li>Returning <code>false</code> keeps default engine behavior unchanged.</li> <li><code>victim:attribute(...)</code>:</li> <li>Reads current and max HP from <code>opengothic.CONSTANTS.Attribute</code>.</li> <li><code>print(...)</code>:</li> <li>Writes developer/test output to stdout instead of in-game UI.</li> </ul>"},{"location":"getting-started/tutorials/your-first-mod/#step-4-run-the-game","title":"Step 4: Run the Game","text":"<p>Test flow:</p> <ol> <li>Launch OpenGothic and load/start a game.</li> <li>Confirm <code>health_monitor loaded</code> appears in script output.</li> <li>Take damage from an enemy.</li> <li>Confirm the HP log line updates on each hit.</li> </ol>"},{"location":"getting-started/tutorials/your-first-mod/#related-tutorials","title":"Related Tutorials","text":"<ul> <li>Creating a Simple Quest</li> <li>Quickloot</li> <li>Dialog Time Windows</li> </ul>"}]}